*deck polvlu
      subroutine polvlu (l, nder, x, yfit, yp, a)
c***begin prologue  polvlu
c***purpose  use the coefficients generated by polfit to evaluate the
c            polynomial fit of degree l, along with the first nder of
c            its derivatives, at a specified point.
c***library   slatec
c***category  k6
c***type      
c***keywords  curve fitting, least squares, polynomial approximation
c***author  shampine, l. f., (snla)
c           davenport, s. m., (snla)
c***description
c
c     abstract
c
c     the subroutine  polvlu  uses the coefficients generated by  polfit
c     to evaluate the polynomial fit of degree  l , along with the first
c     nder  of its derivatives, at a specified point.  computationally
c     stable recurrence relations are used to perform this task.
c
c     the parameters for  polvlu  are
c
c     input -- all type real variables are double precision
c         l -      the degree of polynomial to be evaluated.  l  may be
c                  any non-negative integer which is less than or equal
c                  to  ndeg , the highest degree polynomial provided
c                  by  dpolft .
c         nder -   the number of derivatives to be evaluated.  nder
c                  may be 0 or any positive value.  if nder is less
c                  than 0, it will be treated as 0.
c         x -      the argument at which the polynomial and its
c                  derivatives are to be evaluated.
c         a -      work and output array containing values from last
c                  call to  polfit .
c
c     output -- all type real variables are double precision
c         yfit -   value of the fitting polynomial of degree  l  at  x
c         yp -     array containing the first through  nder  derivatives
c                  of the polynomial of degree  l .  yp  must be
c                  dimensioned at least  nder  in the calling program.
c
c***references  l. f. shampine, s. m. davenport and r. e. huddleston,
c                 curve fitting by polynomials in one variable, report
c                 sla-74-0270, sandia laboratories, june 1974.
c***routines called  xermsg
c***revision history  (yymmdd)
c   740601  date written
c   890531  changed all specific intrinsics to generic.  (wrb)
c   890911  removed unnecessary intrinsics.  (wrb)
c   891006  cosmetic changes to prologue.  (wrb)
c   891006  revision date from version 3.2
c   891214  prologue converted to version 4.0 format.  (bab)
c   900315  calls to xerror changed to calls to xermsg.  (thj)
c   900510  convert xerrwv calls to xermsg calls.  (rwc)
c   920501  reformatted the references section.  (wrb)
c***end prologue  dp1vlu
      implicit real*8 (a-h,o-z)
      integer i,ic,ilo,in,inp1,iup,k1,k1i,k2,k3,k3p1,k3pn,k4,k4p1,k4pn,
     * kc,l,lm1,lp1,maxord,n,nder,ndo,ndp1,nord
      real*8 a(*),cc,dif,val,x,yfit,yp(*)
      common/io/ inp, iout
c***first executable statement  dp1vlu
      if (l .lt. 0) go to 12
      ndo = max(nder,0)
      ndo = min(ndo,l)
      maxord = a(1) + 0.5d0
      k1 = maxord + 1
      k2 = k1 + maxord
      k3 = k2 + maxord + 2
      nord = a(k3) + 0.5d0
      if (l .gt. nord) go to 11
      k4 = k3 + l + 1
      if (nder .lt. 1) go to 2
      do 1 i = 1,nder
 1      yp(i) = 0.0d0
 2    if (l .ge. 2) go to 4
      if (l .eq. 1) go to 3
c
c l is 0
c
      val = a(k2+1)
      go to 10
c
c l is 1
c
 3    cc = a(k2+2)
      val = a(k2+1) + (x-a(2))*cc
      if (nder .ge. 1) yp(1) = cc
      go to 10
c
c l is greater than 1
c
 4    ndp1 = ndo + 1
      k3p1 = k3 + 1
      k4p1 = k4 + 1
      lp1 = l + 1
      lm1 = l - 1
      ilo = k3 + 3
      iup = k4 + ndp1
      do 5 i = ilo,iup
 5      a(i) = 0.0d0
      dif = x - a(lp1)
      kc = k2 + lp1
      a(k4p1) = a(kc)
      a(k3p1) = a(kc-1) + dif*a(k4p1)
      a(k3+2) = a(k4p1)
c
c evaluate recurrence relations for function value and derivatives
c
      do 9 i = 1,lm1
        in = l - i
        inp1 = in + 1
        k1i = k1 + inp1
        ic = k2 + in
        dif = x - a(inp1)
        val = a(ic) + dif*a(k3p1) - a(k1i)*a(k4p1)
        if (ndo .le. 0) go to 8
        do 6 n = 1,ndo
          k3pn = k3p1 + n
          k4pn = k4p1 + n
 6        yp(n) = dif*a(k3pn) + n*a(k3pn-1) - a(k1i)*a(k4pn)
c
c save values needed for next evaluation of recurrence relations
c
        do 7 n = 1,ndo
          k3pn = k3p1 + n
          k4pn = k4p1 + n
          a(k4pn) = a(k3pn)
 7        a(k3pn) = yp(n)
 8      a(k4p1) = a(k3p1)
 9      a(k3p1) = val
c
c normal return or abort due to error
c
 10   yfit = val
      return
c
 11   write(iout,98) l, nord
 98   format('error in polvlu. order of polynomial evaluation l = ',
     1        i3,' exceeds highest order fit nord = ',i3)
      call lnkerr('error in polvlu')
      return
c
   12 write(iout,99)
 99   format ('error in polvlu',
     1   'invalid input parameter.  order of polynomial evaluation ' //
     2   'requested is negative.')
      call lnkerr('error in polvlu')
      return
      end

