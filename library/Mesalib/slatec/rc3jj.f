*deck rc3jj
      subroutine rc3jj (l2, l3, m2, m3, l1min, l1max, thrcof, ndim, ier)
c***begin prologue  rc3jj
c***purpose  evaluate the 3j symbol f(l1) = (  l1   l2 l3)
c                                           (-m2-m3 m2 m3)
c            for all allowed values of l1, the other parameters
c            being held fixed.
c***library   slatec
c***category  c19
c***type      single precision (rc3jj-s, drc3jj-d)
c***keywords  3j coefficients, 3j symbols, clebsch-gordan coefficients,
c             racah coefficients, vector addition coefficients,
c             wigner coefficients
c***author  gordon, r. g., harvard university
c           schulten, k., max planck institute
c***description
c
c *usage:
c
c        real l2, l3, m2, m3, l1min, l1max, thrcof(ndim)
c        integer ndim, ier
c
c        call rc3jj (l2, l3, m2, m3, l1min, l1max, thrcof, ndim, ier)
c
c *arguments:
c
c     l2 :in      parameter in 3j symbol.
c
c     l3 :in      parameter in 3j symbol.
c
c     m2 :in      parameter in 3j symbol.
c
c     m3 :in      parameter in 3j symbol.
c
c     l1min :out  smallest allowable l1 in 3j symbol.
c
c     l1max :out  largest allowable l1 in 3j symbol.
c
c     thrcof :out set of 3j coefficients generated by evaluating the
c                 3j symbol for all allowed values of l1.  thrcof(i)
c                 will contain f(l1min+i-1), i=1,2,...,l1max+l1min+1.
c
c     ndim :in    declared length of thrcof in calling program.
c
c     ier :out    error flag.
c                 ier=0 no errors.
c                 ier=1 either l2.lt.abs(m2) or l3.lt.abs(m3).
c                 ier=2 either l2+abs(m2) or l3+abs(m3) non-integer.
c                 ier=3 l1max-l1min not an integer.
c                 ier=4 l1max less than l1min.
c                 ier=5 ndim less than l1max-l1min+1.
c
c *description:
c
c     although conventionally the parameters of the vector addition
c  coefficients satisfy certain restrictions, such as being integers
c  or integers plus 1/2, the restrictions imposed on input to this
c  subroutine are somewhat weaker. see, for example, section 27.9 of
c  abramowitz and stegun or appendix c of volume ii of a. messiah.
c  the restrictions imposed by this subroutine are
c       1. l2 .ge. abs(m2) and l3 .ge. abs(m3);
c       2. l2+abs(m2) and l3+abs(m3) must be integers;
c       3. l1max-l1min must be a non-negative integer, where
c          l1max=l2+l3 and l1min=max(abs(l2-l3),abs(m2+m3)).
c  if the conventional restrictions are satisfied, then these
c  restrictions are met.
c
c     the user should be cautious in using input parameters that do
c  not satisfy the conventional restrictions. for example, the
c  the subroutine produces values of
c       f(l1) = ( l1  2.5  5.8)
c               (-0.3 1.5 -1.2)
c  for l1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j
c  symbol, set forth on page 1056 of messiah, is satisfied.
c
c     the subroutine generates f(l1min), f(l1min+1), ..., f(l1max)
c  where l1min and l1max are defined above. the sequence f(l1) is
c  generated by a three-term recurrence algorithm with scaling to
c  control overflow. both backward and forward recurrence are used to
c  maintain numerical stability. the two recurrence sequences are
c  matched at an interior point and are normalized from the unitary
c  property of 3j coefficients and wigner's phase convention.
c
c    the algorithm is suited to applications in which large quantum
c  numbers arise, such as in molecular dynamics.
c
c***references  1. abramowitz, m., and stegun, i. a., eds., handbook
c                  of mathematical functions with formulas, graphs
c                  and mathematical tables, nbs applied mathematics
c                  series 55, june 1964 and subsequent printings.
c               2. messiah, albert., quantum mechanics, volume ii,
c                  north-holland publishing company, 1963.
c               3. schulten, klaus and gordon, roy g., exact recursive
c                  evaluation of 3j and 6j coefficients for quantum-
c                  mechanical coupling of angular momenta, j math
c                  phys, v 16, no. 10, october 1975, pp. 1961-1970.
c               4. schulten, klaus and gordon, roy g., semiclassical
c                  approximations to 3j  and 6j coefficients for
c                  quantum-mechanical coupling of angular momenta,
c                  j math phys, v 16, no. 10, october 1975,
c                  pp. 1971-1988.
c               5. schulten, klaus and gordon, roy g., recursive
c                  evaluation of 3j and 6j coefficients, computer
c                  phys comm, v 11, 1976, pp. 269-278.
c***routines called  r1mach, xermsg
c***revision history  (yymmdd)
c   750101  date written
c   880515  slatec prologue added by g. c. nielson, nbs; parameters
c           huge and tiny revised to depend on r1mach.
c   891229  prologue description rewritten; other prologue sections
c           revised; lmatch (location of match point for recurrences)
c           removed from argument list; argument ier changed to serve
c           only as an error flag (previously, in cases without error,
c           it returned the number of scalings); number of error codes
c           increased to provide more precise error information;
c           program comments revised; slatec error handler calls
c           introduced to enable printing of error messages to meet
c           slatec standards. these changes were done by d. w. lozier,
c           m. a. mcclain and j. m. smith of the national institute
c           of standards and technology, formerly nbs.
c   910415  mixed type expressions eliminated; variable c1 initialized;
c           description of thrcof expanded. these changes were done by
c           d. w. lozier.
c***end prologue  rc3jj
c
      integer ndim, ier
      real l2, l3, m2, m3, l1min, l1max, thrcof(ndim)
c
      integer i, index, lstep, n, nfin, nfinp1, nfinp2, nfinp3, nlim,
     +        nstep2
      real a1, a1s, a2, a2s, c1, c1old, c2, cnorm, r1mach,
     +     denom, dv, eps, huge, l1, m1, newfac, oldfac,
     +     one, ratio, sign1, sign2, srhuge, srtiny, sum1,
     +     sum2, sumbac, sumfor, sumuni, three, thresh,
     +     tiny, two, x, x1, x2, x3, y, y1, y2, y3, zero
c
      data  zero,eps,one,two,three /0.0,0.01,1.0,2.0,3.0/
c
c***first executable statement  rc3jj
      ier=0
c  huge is the square root of one twentieth of the largest floating
c  point number, approximately.
      huge = sqrt(r1mach(2)/20.0)
      srhuge = sqrt(huge)
      tiny = 1.0/huge
      srtiny = 1.0/srhuge
c
c     lmatch = zero
      m1 = - m2 - m3
c
c  check error conditions 1 and 2.
      if((l2-abs(m2)+eps.lt.zero).or.
     +   (l3-abs(m3)+eps.lt.zero))then
         ier=1
         call xermsg('slatec','rc3jj','l2-abs(m2) or l3-abs(m3) '//
     +      'less than zero.',ier,1)
         return
      elseif((mod(l2+abs(m2)+eps,one).ge.eps+eps).or.
     +   (mod(l3+abs(m3)+eps,one).ge.eps+eps))then
         ier=2
         call xermsg('slatec','rc3jj','l2+abs(m2) or l3+abs(m3) '//
     +      'not integer.',ier,1)
         return
      endif
c
c
c
c  limits for l1
c
      l1min = max(abs(l2-l3),abs(m1))
      l1max = l2 + l3
c
c  check error condition 3.
      if(mod(l1max-l1min+eps,one).ge.eps+eps)then
         ier=3
         call xermsg('slatec','rc3jj','l1max-l1min not integer.',ier,1)
         return
      endif
      if(l1min.lt.l1max-eps)   go to 20
      if(l1min.lt.l1max+eps)   go to 10
c
c  check error condition 4.
      ier=4
      call xermsg('slatec','rc3jj','l1min greater than l1max.',ier,1)
      return
c
c  this is reached in case that l1 can take only one value,
c  i.e. l1min = l1max
c
   10 continue
c     lscale = 0
      thrcof(1) = (-one) ** int(abs(l2+m2-l3+m3)+eps) /
     1 sqrt(l1min + l2 + l3 + one)
      return
c
c  this is reached in case that l1 takes more than one value,
c  i.e. l1min < l1max.
c
   20 continue
c     lscale = 0
      nfin = int(l1max-l1min+one+eps)
      if(ndim-nfin)  21, 23, 23
c
c  check error condition 5.
   21 ier = 5
      call xermsg('slatec','rc3jj','dimension of result array for 3j '//
     +            'coefficients too small.',ier,1)
      return
c
c
c  starting forward recursion from l1min taking nstep1 steps
c
   23 l1 = l1min
      newfac = 0.0
      c1 = 0.0
      thrcof(1) = srtiny
      sum1 = (l1+l1+one) * tiny
c
c
      lstep = 1
   30 lstep = lstep + 1
      l1 = l1 + one
c
c
      oldfac = newfac
      a1 = (l1+l2+l3+one) * (l1-l2+l3) * (l1+l2-l3) * (-l1+l2+l3+one)
      a2 = (l1+m1) * (l1-m1)
      newfac = sqrt(a1*a2)
      if(l1.lt.one+eps)   go to 40
c
c
      dv = - l2*(l2+one) * m1 + l3*(l3+one) * m1 + l1*(l1-one) * (m3-m2)
      denom = (l1-one) * newfac
c
      if(lstep-2)  32, 32, 31
c
   31 c1old = abs(c1)
   32 c1 = - (l1+l1-one) * dv / denom
      go to 50
c
c  if l1 = 1, (l1-1) has to be factored out of dv, hence
c
   40 c1 = - (l1+l1-one) * l1 * (m3-m2) / newfac
c
   50 if(lstep.gt.2)   go to 60
c
c
c  if l1 = l1min + 1, the third term in the recursion equation vanishes,
c  hence
      x = srtiny * c1
      thrcof(2) = x
      sum1 = sum1 + tiny * (l1+l1+one) * c1*c1
      if(lstep.eq.nfin)   go to 220
      go to 30
c
c
   60 c2 = - l1 * oldfac / denom
c
c  recursion to the next 3j coefficient x
c
      x = c1 * thrcof(lstep-1) + c2 * thrcof(lstep-2)
      thrcof(lstep) = x
      sumfor = sum1
      sum1 = sum1 + (l1+l1+one) * x*x
      if(lstep.eq.nfin)   go to 100
c
c  see if last unnormalized 3j coefficient exceeds srhuge
c
      if(abs(x).lt.srhuge)   go to 80
c
c  this is reached if last 3j coefficient larger than srhuge,
c  so that the recursion series thrcof(1), ... , thrcof(lstep)
c  has to be rescaled to prevent overflow
c
c     lscale = lscale + 1
      do 70 i=1,lstep
      if(abs(thrcof(i)).lt.srtiny)   thrcof(i) = zero
   70 thrcof(i) = thrcof(i) / srhuge
      sum1 = sum1 / huge
      sumfor = sumfor / huge
      x = x / srhuge
c
c  as long as abs(c1) is decreasing, the recursion proceeds towards
c  increasing 3j values and, hence, is numerically stable.  once
c  an increase of abs(c1) is detected, the recursion direction is
c  reversed.
c
   80 if(c1old-abs(c1))   100, 100, 30
c
c
c  keep three 3j coefficients around lmatch for comparison with
c  backward recursion.
c
  100 continue
c     lmatch = l1 - 1
      x1 = x
      x2 = thrcof(lstep-1)
      x3 = thrcof(lstep-2)
      nstep2 = nfin - lstep + 3
c
c
c
c
c  starting backward recursion from l1max taking nstep2 steps, so
c  that forward and backward recursion overlap at three points
c  l1 = lmatch+1, lmatch, lmatch-1.
c
      nfinp1 = nfin + 1
      nfinp2 = nfin + 2
      nfinp3 = nfin + 3
      l1 = l1max
      thrcof(nfin) = srtiny
      sum2 = tiny * (l1+l1+one)
c
      l1 = l1 + two
      lstep = 1
  110 lstep = lstep + 1
      l1 = l1 - one
c
      oldfac = newfac
      a1s = (l1+l2+l3)*(l1-l2+l3-one)*(l1+l2-l3-one)*(-l1+l2+l3+two)
      a2s = (l1+m1-one) * (l1-m1-one)
      newfac = sqrt(a1s*a2s)
c
      dv = - l2*(l2+one) * m1 + l3*(l3+one) * m1 + l1*(l1-one) * (m3-m2)
c
      denom = l1 * newfac
      c1 = - (l1+l1-one) * dv / denom
      if(lstep.gt.2)   go to 120
c
c  if l1 = l1max + 1, the third term in the recursion formula vanishes
c
      y = srtiny * c1
      thrcof(nfin-1) = y
      sumbac = sum2
      sum2 = sum2 + tiny * (l1+l1-three) * c1*c1
c
      go to 110
c
c
  120 c2 = - (l1 - one) * oldfac / denom
c
c  recursion to the next 3j coefficient y
c
      y = c1 * thrcof(nfinp2-lstep) + c2 * thrcof(nfinp3-lstep)
c
      if(lstep.eq.nstep2)   go to 200
c
      thrcof(nfinp1-lstep) = y
      sumbac = sum2
      sum2 = sum2 + (l1+l1-three) * y*y
c
c  see if last unnormalized 3j coefficient exceeds srhuge
c
      if(abs(y).lt.srhuge)   go to 110
c
c  this is reached if last 3j coefficient larger than srhuge,
c  so that the recursion series thrcof(nfin), ... ,thrcof(nfin-lstep+1)
c  has to be rescaled to prevent overflow
c
c     lscale = lscale + 1
      do 130 i=1,lstep
      index = nfin - i + 1
      if(abs(thrcof(index)).lt.srtiny)   thrcof(index) = zero
  130 thrcof(index) = thrcof(index) / srhuge
      sum2 = sum2 / huge
      sumbac = sumbac / huge
c
c
      go to 110
c
c
c  the forward recursion 3j coefficients x1, x2, x3 are to be matched
c  with the corresponding backward recursion values y1, y2, y3.
c
  200 y3 = y
      y2 = thrcof(nfinp2-lstep)
      y1 = thrcof(nfinp3-lstep)
c
c
c  determine now ratio such that yi = ratio * xi  (i=1,2,3) holds
c  with minimal error.
c
      ratio = ( x1*y1 + x2*y2 + x3*y3 ) / ( x1*x1 + x2*x2 + x3*x3 )
      nlim = nfin - nstep2 + 1
c
      if(abs(ratio).lt.one)   go to 211
c
      do 210 n=1,nlim
  210 thrcof(n) = ratio * thrcof(n)
      sumuni = ratio * ratio * sumfor + sumbac
      go to 230
c
  211 nlim = nlim + 1
      ratio = one / ratio
      do 212 n=nlim,nfin
  212 thrcof(n) = ratio * thrcof(n)
      sumuni = sumfor + ratio*ratio*sumbac
      go to 230
c
  220 sumuni = sum1
c
c
c  normalize 3j coefficients
c
  230 cnorm = one / sqrt(sumuni)
c
c  sign convention for last 3j coefficient determines overall phase
c
      sign1 = sign(one,thrcof(nfin))
      sign2 = (-one) ** int(abs(l2+m2-l3+m3)+eps)
      if(sign1*sign2) 235,235,236
  235 cnorm = - cnorm
c
  236 if(abs(cnorm).lt.one)   go to 250
c
      do 240 n=1,nfin
  240 thrcof(n) = cnorm * thrcof(n)
      return
c
  250 thresh = tiny / abs(cnorm)
      do 251 n=1,nfin
      if(abs(thrcof(n)).lt.thresh)   thrcof(n) = zero
  251 thrcof(n) = cnorm * thrcof(n)
c
      return
      end
