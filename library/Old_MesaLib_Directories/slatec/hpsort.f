*deck hpsort
      subroutine hpsort (hx, n, strbeg, strend, iperm, kflag, work, ier)
c***begin prologue  hpsort
c***purpose  return the permutation vector generated by sorting a
c            substring within a character array and, optionally,
c            rearrange the elements of the array.  the array may be
c            sorted in forward or reverse lexicographical order.  a
c            slightly modified quicksort algorithm is used.
c***library   slatec
c***category  n6a1c, n6a2c
c***type      character (spsort-s, dpsort-d, ipsort-i, hpsort-h)
c***keywords  passive sorting, singleton quicksort, sort, string sorting
c***author  jones, r. e., (snla)
c           rhoads, g. s., (nbs)
c           sullivan, f. e., (nbs)
c           wisniewski, j. a., (snla)
c***description
c
c   hpsort returns the permutation vector iperm generated by sorting
c   the substrings beginning with the character strbeg and ending with
c   the character strend within the strings in array hx and, optionally,
c   rearranges the strings in hx.   hx may be sorted in increasing or
c   decreasing lexicographical order.  a slightly modified quicksort
c   algorithm is used.
c
c   iperm is such that hx(iperm(i)) is the ith value in the
c   rearrangement of hx.  iperm may be applied to another array by
c   calling ipperm, spperm, dpperm or hpperm.
c
c   an active sort of numerical data is expected to execute somewhat
c   more quickly than a passive sort because there is no need to use
c   indirect references. but for the character data in hpsort, integers
c   in the iperm vector are manipulated rather than the strings in hx.
c   moving integers may be enough faster than moving character strings
c   to more than offset the penalty of indirect referencing.
c
c   description of parameters
c      hx - input/output -- array of type character to be sorted.
c           for example, to sort a 80 element array of names,
c           each of length 6, declare hx as character hx(100)*6.
c           if abs(kflag) = 2, then the values in hx will be
c           rearranged on output; otherwise, they are unchanged.
c      n  - input -- number of values in array hx to be sorted.
c      strbeg - input -- the index of the initial character in
c               the string hx that is to be sorted.
c      strend - input -- the index of the final character in
c               the string hx that is to be sorted.
c      iperm - output -- permutation array such that iperm(i) is the
c              index of the string in the original order of the
c              hx array that is in the ith location in the sorted
c              order.
c      kflag - input -- control parameter:
c            =  2  means return the permutation vector resulting from
c                  sorting hx in lexicographical order and sort hx also.
c            =  1  means return the permutation vector resulting from
c                  sorting hx in lexicographical order and do not sort
c                  hx.
c            = -1  means return the permutation vector resulting from
c                  sorting hx in reverse lexicographical order and do
c                  not sort hx.
c            = -2  means return the permutation vector resulting from
c                  sorting hx in reverse lexicographical order and sort
c                  hx also.
c      work - character variable which must have a length specification
c             at least as great as that of hx.
c      ier - output -- error indicator:
c          =  0  if no error,
c          =  1  if n is zero or negative,
c          =  2  if kflag is not 2, 1, -1, or -2,
c          =  3  if work array is not long enough,
c          =  4  if string beginning is beyond its end,
c          =  5  if string beginning is out-of-range,
c          =  6  if string end is out-of-range.
c
c     e x a m p l e  o f  u s e
c
c      character*2 hx, w
c      integer strbeg, strend
c      dimension hx(10), iperm(10)
c      data (hx(i),i=1,10)/ '05','i ',' i','  ','rs','9r','r9','89',
c     1     ',*','n"'/
c      data strbeg, strend / 1, 2 /
c      call hpsort (hx,10,strbeg,strend,iperm,1,w)
c      print 100, (hx(iperm(i)),i=1,10)
c 100 format (2x, a2)
c      stop
c      end
c
c***references  r. c. singleton, algorithm 347, an efficient algorithm
c                 for sorting with minimal storage, communications of
c                 the acm, 12, 3 (1969), pp. 185-187.
c***routines called  xermsg
c***revision history  (yymmdd)
c   761101  date written
c   761118  modified by john a. wisniewski to use the singleton
c           quicksort algorithm.
c   811001  modified by francis sullivan for string data.
c   850326  documentation slightly modified by d. kahaner.
c   870423  modified by gregory s. rhoads for passive sorting with the
c           option for the rearrangement of the original data.
c   890620  algorithm for rearranging the data vector corrected by r.
c           boisvert.
c   890622  prologue upgraded to version 4.0 style by d. lozier.
c   920507  modified by m. mcclain to revise prologue text.
c   920818  declarations section rebuilt and code restructured to use
c           if-then-else-endif.  (smr, wrb)
c***end prologue  hpsort
c     .. scalar arguments ..
      integer ier, kflag, n, strbeg, strend
      character * (*) work
c     .. array arguments ..
      integer iperm(*)
      character * (*) hx(*)
c     .. local scalars ..
      real r
      integer i, ij, indx, indx0, ir, istrt, j, k, kk, l, lm, lmt, m,
     +        nn, nn2
c     .. local arrays ..
      integer il(21), iu(21)
c     .. external subroutines ..
      external xermsg
c     .. intrinsic functions ..
      intrinsic abs, int, len
c***first executable statement  hpsort
      ier = 0
      nn = n
      if (nn .lt. 1) then
         ier = 1
         call xermsg ('slatec', 'hpsort',
     +    'the number of values to be sorted, n, is not positive.',
     +    ier, 1)
         return
      endif
      kk = abs(kflag)
      if (kk.ne.1 .and. kk.ne.2) then
         ier = 2
         call xermsg ('slatec', 'hpsort',
     +    'the sort control parameter, kflag, is not 2, 1, -1, or -2.',
     +    ier, 1)
         return
      endif
c
      if(len(work) .lt. len(hx(1))) then
         ier = 3
         call xermsg ('slatec',' hpsort',
     +    'the length of the work variable, work, is too short.',
     +    ier, 1)
         return
      endif
      if (strbeg .gt. strend) then
         ier = 4
         call xermsg ('slatec', 'hpsort',
     +    'the string beginning, strbeg, is beyond its end, strend.',
     +    ier, 1)
         return
      endif
      if (strbeg .lt. 1 .or. strbeg .gt. len(hx(1))) then
         ier = 5
         call xermsg ('slatec', 'hpsort',
     +    'the string beginning, strbeg, is out-of-range.',
     +    ier, 1)
         return
      endif
      if (strend .lt. 1 .or. strend .gt. len(hx(1))) then
         ier = 6
         call xermsg ('slatec', 'hpsort',
     +    'the string end, strend, is out-of-range.',
     +    ier, 1)
         return
      endif
c
c     initialize permutation vector
c
      do 10 i=1,nn
         iperm(i) = i
   10 continue
c
c     return if only one value is to be sorted
c
      if (nn .eq. 1) return
c
c     sort hx only
c
      m = 1
      i = 1
      j = nn
      r = .375e0
c
   20 if (i .eq. j) go to 70
      if (r .le. 0.5898437e0) then
         r = r+3.90625e-2
      else
         r = r-0.21875e0
      endif
c
   30 k = i
c
c     select a central element of the array and save it in location l
c
      ij = i + int((j-i)*r)
      lm = iperm(ij)
c
c     if first element of array is greater than lm, interchange with lm
c
      if (hx(iperm(i))(strbeg:strend) .gt. hx(lm)(strbeg:strend)) then
         iperm(ij) = iperm(i)
         iperm(i) = lm
         lm = iperm(ij)
      endif
      l = j
c
c     if last element of array is less than lm, interchange with lm
c
      if (hx(iperm(j))(strbeg:strend) .lt. hx(lm)(strbeg:strend)) then
         iperm(ij) = iperm(j)
         iperm(j) = lm
         lm = iperm(ij)
c
c        if first element of array is greater than lm, interchange
c        with lm
c
         if (hx(iperm(i))(strbeg:strend) .gt. hx(lm)(strbeg:strend))
     +      then
               iperm(ij) = iperm(i)
               iperm(i) = lm
               lm = iperm(ij)
         endif
      endif
      go to 50
   40 lmt = iperm(l)
      iperm(l) = iperm(k)
      iperm(k) = lmt
c
c     find an element in the second half of the array which is smaller
c     than lm
c
   50 l = l-1
      if (hx(iperm(l))(strbeg:strend) .gt. hx(lm)(strbeg:strend))
     +    go to 50
c
c     find an element in the first half of the array which is greater
c     than lm
c
   60 k = k+1
      if (hx(iperm(k))(strbeg:strend) .lt. hx(lm)(strbeg:strend))
     +   go to 60
c
c     interchange these elements
c
      if (k .le. l) go to 40
c
c     save upper and lower subscripts of the array yet to be sorted
c
      if (l-i .gt. j-k) then
         il(m) = i
         iu(m) = l
         i = k
         m = m+1
      else
         il(m) = k
         iu(m) = j
         j = l
         m = m+1
      endif
      go to 80
c
c     begin again on another portion of the unsorted array
c
   70 m = m-1
      if (m .eq. 0) go to 110
      i = il(m)
      j = iu(m)
c
   80 if (j-i .ge. 1) go to 30
      if (i .eq. 1) go to 20
      i = i-1
c
   90 i = i+1
      if (i .eq. j) go to 70
      lm = iperm(i+1)
      if (hx(iperm(i))(strbeg:strend) .le. hx(lm)(strbeg:strend))
     +   go to 90
      k = i
c
  100 iperm(k+1) = iperm(k)
      k = k-1
c
      if (hx(lm)(strbeg:strend) .lt. hx(iperm(k))(strbeg:strend))
     +    go to 100
      iperm(k+1) = lm
      go to 90
c
c     clean up
c
  110 if (kflag .le. -1) then
c
c        alter array to get reverse order, if necessary
c
         nn2 = nn/2
         do 120 i=1,nn2
           ir = nn-i+1
           lm = iperm(i)
           iperm(i) = iperm(ir)
           iperm(ir) = lm
  120    continue
      endif
c
c     rearrange the values of hx if desired
c
      if (kk .eq. 2) then
c
c        use the iperm vector as a flag.
c        if iperm(i) < 0, then the i-th value is in correct location
c
         do 140 istrt=1,nn
            if (iperm(istrt) .ge. 0) then
               indx = istrt
               indx0 = indx
               work = hx(istrt)
  130          if (iperm(indx) .gt. 0) then
                  hx(indx) = hx(iperm(indx))
                  indx0 = indx
                  iperm(indx) = -iperm(indx)
                  indx = abs(iperm(indx))
                  go to 130
               endif
               hx(indx0) = work
            endif
  140    continue
c
c        revert the signs of the iperm values
c
         do 150 i=1,nn
            iperm(i) = -iperm(i)
  150    continue
c
      endif
c
      return
      end
