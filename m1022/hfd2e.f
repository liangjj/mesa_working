*deck @(#)hfd2e.f	5.1  11/6/94
      subroutine hfd2e(ds,nnp,nder,udep,nindep,u,num,w,dlag,sa,d2e,
     $     nd2e,ld2e,pt,minshl,maxshl,numshl,nshell,ops)
c
c***begin prologue     hfd2e
c***date written       871128  (yymmdd)
c***revision date      880109  (yymmdd)
c
c   09 january 1988    bhl at brl
c   changed final output to write "cartesian second derivatives"
c   instead of " hf second derivatives" for unified treatment of
c   scf, mcscf, ci etc.
c
c***keywords           hf second derivative energy expression
c***author             saxe, paul (lanl)
c***source             @(#)hfd2e.f	5.1   11/6/94
c***purpose            form the second derivative contribution from the
c                      cphf solutions.
c***description
c
c    this routine forms the following two contributions to the hf
c    second derivatives:
c
c    d2e               occ occ
c    ---   =  ...  - 2 sum sum ds(ij,a) * dlag(ij,b)
c    dadb               i   j
c
c                      all occ
c                  +   sum sum u(i,j,b) * omega(ij,a)
c                       i   j
c
c    these terms are then added to the integral terms generated by
c    m702 and m712 to form the entire hf second derivative matrix.
c
c
c n.b.  udep may be overlapped with any array except u.
c       u and dlag may be overlapped.
c       sa and wa may be overlapped.
c
c***references         "unified theoretical treatment of analytic first
c                       and second derivatives in open-shell hartree-
c                       fock theory", y. osamura, y. yamaguchi, p. saxe,
c                       m. a. vincent, j. f. gaw and h. f. schaefer iii,
c                       chemical physics 72 (1983) 131-139.
c
c***routines called    iosys
c
c***end prologue       hfd2e
c
      implicit integer (a-z)
c
      character*3 answer
      character*(*) ops
      integer pt(nnp)
      integer minshl(nshell)
      integer maxshl(nshell)
      integer numshl(nshell)
      logical logkey
      real*8 ds(nnp,nder)
      real*8 udep(nindep,nder)
      real*8 u(num,num,nder)
      real*8 w(num,num,nder)
      real*8 dlag(num,num,nder)
      real*8 sa(num,num)
      real*8 d2e(nd2e)
      real*8 ld2e(nd2e)
c
      common /io/ inp,iout
c
      iadd(i,j)=i*(i-1)/2+j
c
      call iosys('does "cphf solutions" exist on rwf',0,0,0,answer)
      if (answer.eq.'yes') then
c
c        ---- get filled out cphf solutions if the exist -----
c
         write (iout,234)
 234     format ('    using cphf solutions from m1021')
c
         call iosys('read real "cphf solutions" from rwf',
     $        num**2*nder,u,0,' ')
c
c        ----- read in the derivative overlap integrals -----
c
         call iosys('read real "mo derivative overlap integrals" '//
     $        'from rwf',nnp*nder,ds,0,' ')
      else
c
c        ----- read in the dependent elements of u and fill out -----
c
         call iosys('read real "independent cphf solutions" from rwf',
     $        nindep*nder,udep,0,' ')
c
         call rzero(u,num*num*nder)
c
         do 5 ishell=2,nshell
            do 4 jshell=1,ishell-1
               do 3 i=minshl(ishell),maxshl(ishell)
                  ia=i*(i-1)/2
                  do 2 j=minshl(jshell),maxshl(jshell)
                     ij=ia+j
                     pij=pt(ij)
                     do 1 der=1,nder
                        u(i,j,der)=udep(pij,der)
 1                   continue
 2                continue
 3             continue
 4          continue
 5       continue
c
c        ----- read in the derivative overlap integrals -----
c
         call iosys('read real "mo derivative overlap integrals" '//
     $        'from rwf',nnp*nder,ds,0,' ')
c
c        ----- u(i,j)+ds(ij)+u(j,i) = 0 -----
c
         do 8 i=1,num
            ia=i*(i-1)/2
            do 7 j=1,i-1
               ij=ia+j
               do 6 der=1,nder
                  u(j,i,der)=-u(i,j,der)-ds(ij,der)
 6             continue
 7          continue
            ii=ia+i
            do 340 der=1,nder
               u(i,i,der)=-ds(ii,der)/2
 340        continue
 8       continue
      end if
c
c     ----- and get the omega (wa) vectors -----
c
      call iosys('read real "derivative omegas" from rwf',
     $     num*num*nder,w,0,' ')
c
c     ----- form the u(ij,b) * w(ij,a) part of second derivatives -----
c
      call rzero(d2e,nd2e)
c
      do 14 a=1,nder
         do 13 b=1,a
            ab=iadd(a,b)
            do 12 ishell=1,nshell
               do 11 jshell=1,nshell-1
                  do 10 i=minshl(ishell),maxshl(ishell)
                     do 9 j=minshl(jshell),maxshl(jshell)
                        d2e(ab)=d2e(ab)+u(i,j,b)*w(i,j,a)
 9                   continue
 10               continue
 11            continue
 12         continue
 13      continue
 14   continue
c
c
      if (logkey(ops,'print=second-derivative=cphf-term',.false.,' '))
     $     then
         write (iout,1000)
 1000    format (/,10x,'the cphf contribution to the second ',
     $        'derivatives',/,10x,'   u(ij,b) * omega(ij,a)')
         call print(d2e,nd2e,nder,iout)
      end if
c
c
      call iosys('read real "mo derivative hf lagrangian" from rwf',
     #            num**2*nder,dlag,0,' ')
c
c     ----- form the s(ij,a) * e(ij,b) part of second derivatives -----
c
      call rzero(ld2e,nd2e)
c
      do 20 a=1,nder
         call trtosq(sa,ds(1,a),num,nnp)
         do 19 b=1,a
            ab=iadd(a,b)
            do 18 ishell=1,nshell-1
               do 17 jshell=1,nshell-1
                  do 16 i=minshl(ishell),maxshl(ishell)
                     do 15 j=minshl(jshell),maxshl(jshell)
                        ld2e(ab)=ld2e(ab)-2*sa(i,j)*dlag(i,j,b)
 15                  continue
 16               continue
 17            continue
 18         continue
 19      continue
 20   continue
c
c
      if (logkey(ops,'print=second-derivative=sa*eb-term',.false.,' '))
     $     then
         write (iout,1001)
 1001    format (/,10x,'the sa-eb contribution to the second ',
     $        'derivatives',/,10x,'   s(ij,a) * lag(ij,b)')
         call print(ld2e,nd2e,nder,iout)
      end if
c
c
      do 21 i=1,nd2e
         d2e(i)=d2e(i)+ld2e(i)
 21   continue
c
c
      call iosys('read real "integral force constants" from rwf',
     $     nd2e,ld2e,0,' ')
c
      do 22 i=1,nd2e
         d2e(i)=d2e(i)+ld2e(i)
 22   continue
c
c
      if (logkey(ops,'print=second-derivative=total',.false.,' '))
     $     then
         write (iout,1002)
 1002    format (/,10x,'the total hf second derivatives')
         call print(d2e,nd2e,nder,iout)
      end if
c
c
      call iosys('write real "cartesian second derivatives" to rwf',
     $     nd2e,d2e,0,' ')
c
c
      return
      end
