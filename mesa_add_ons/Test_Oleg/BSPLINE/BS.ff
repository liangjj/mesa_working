!--------------------------------------------------------------
!     BS LIBRARY
!--------------------------------------------------------------
!
!     contains routines for B-spline calculations
!
!--------------------------------------------------------------
!
!     MODULES:
!
!     Spline_param.f90
!     Spline_atomic.f90
!     Spline_galerkin.f90
!     Spline_grid.f90
!     Spline_hl.f90
!     Spline_integrals.f90
!     Spline_moments.f90
!     Spline_orbitals.f90
!     Spline_slater.f90
!
!--------------------------------------------------------------
!
!     ROUTINES:
!
!     azl.f90
!     bav.f90
!     bcore.f90
!     bhl.f90
!     bhwf.f90
!     bvalue2.f90
!     bvmv.f90
!     bxv.f90
!     bzk.f90
!     convol.f90
!     coulom.f90
!     define_grid.f90
!     define_spline.f90
!     density.f90
!     dinty.f90
!     dvx.f90
!     facdyk.f90
!     facdzk.f90
!     facsb.f90
!     facsbl.f90
!     gauss.f90
!     grad.f90
!     hlc.f90
!     hlm.f90
!     int_de.f90
!     int_v.f90
!     minty.f90
!     mk.f90
!     mkc.f90
!     mkgrid2.f90
!     mky.f90
!     mk_moments.f90
!     mmk_cell.f90
!     mmk_diff.f90
!     mnk_cell.f90
!     mnk_diff.f90
!     moments.f90
!     mqk_cell.f90
!     mrk_cell.f90
!     mrk_diff.f90
!     mrm.f90
!     mtk_cell.f90
!     mtk_diff.f90
!     mvc.f90
!     mvcv.f90
!     mvk_cell.f90
!     mvk_diff.f90
!     mwk_cell.f90
!     nk.f90
!     nkc.f90
!     nky.f90
!     nk_moments.f90
!     qk.f90
!     qkc.f90
!     qky.f90
!     qk_moments.f90
!     quadr.f90
!     rk.f90
!     rkc.f90
!     rky.f90
!     rk_moments.f90
!     r_bwfn.f90
!     splin3.f90
!     sum_amb.f90
!     tk.f90
!     tkc.f90
!     tky.f90
!     tk_moments.f90
!     vbsplvd.f90
!     vinty.f90
!     vk.f90
!     vkc.f90
!     vky.f90
!     vk_moments.f90
!     wk.f90
!     wky.f90
!     wk_moments.f90
!     ykf.f90
!     yval.f90
!     zeta_y.f90
!
!--------------------------------------------------------------
!
!     Oleg Zatsarinny, COPYRIGHT 2005, oleg_zoi@yahoo.com
!
!--------------------------------------------------------------


!====================================================================
    MODULE spline_param
!====================================================================
!
!   contains basic spline parameters
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    INTEGER(4) :: grid_type = 0   !  type of grid
    INTEGER(4) :: nug = 99
    Character(40) :: AF_grid = 'knot.dat'
    INTEGER(4) :: ks = 8  !   order of B-splines
    INTEGER(4) :: ns = 0  !   number of splines
    INTEGER(4) :: nv = 0  !   number of intervals ( = ns-ks+1 )
    INTEGER(4) :: ml = 0  !   number of intervals from 0 to 1 (=1/h)
    INTEGER(4) :: me = 0  !   number of intervals in the exponential region
    REAL(8) :: h = 0.25    !   initial step in the knot sequence for z*r
    REAL(8) :: hmax = 0.25 !   maximum step, t(ns+1) - t(ns)
    REAL(8) :: rmax = 1.00 !   border radius, t(ns+1)
    END MODULE spline_param


!====================================================================
    MODULE spline_atomic
!====================================================================
!
!   contains some atomic parameters
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    REAL(KIND=8) :: z  = 0.d0   ! nuclear charge
    REAL(KIND=8) :: EC = 0.d0   ! core energy
    REAL(KIND=8) :: fine = 0.25D0/(137.036D0)**2
    LOGICAL :: rel = .FALSE.    ! relativistic corrections
    INTEGER :: irel  =  0       ! the same
    INTEGER :: kclosd = 0       ! closed shells
    INTEGER :: MASS =   0       ! mass-corrections
    INTEGER :: ioo =    0       ! orbit-orbit interaction
    END MODULE spline_atomic


!====================================================================
   MODULE spline_galerkin
!====================================================================
!
!  contains common arrays used in the application of splines and
!  the Galerkin method
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    REAL(KIND=8), ALLOCATABLE, DIMENSION(:,:):: r1, rm1, rm2, rm3
    REAL(KIND=8), ALLOCATABLE, DIMENSION(:,:):: sb, bs, db1, db2
! ...  sb (1:ns,1:ks)  -  sb (i,j) -->  <B_i|B_i+j-k>
! ...  r1 (1:ns,1:ks)  -  r1 (i,j) -->  <B_i|r|B_i+j-k>
! ...  rm1(1:ns,1:ks)  -  rm1(i,j) -->  <B_i|1/r|B_i+j-k>
! ...  rm2(1:ns,1:ks)  -  rm2(i,j) -->  <B_i|1/r^2|B_i+j-k>
! ...  rm3(1:ns,1:ks)  -  rm2(i,j) -->  <B_i|1/r^3|B_i+j-k>
! ...  db1(1:ns,1:ks)  -  db1(i,j) -->  <B_i|B'_i+j-k>
! ...  db2(1:ns,1:ks)  -  db2(i,j) -->  <B_i|B'_i+j-k>
! ...  bs(1:ks,1:ns)   -  factorization of sb
! ...  all arrays (except bs) in the symmetric lower-columb storage
! ...  mode, db2 - 'almost' symmetruc, db1 - antisymmetric
    CONTAINS
!====================================================================
    SUBROUTINE allocate_galerkin
!====================================================================
!
!   allocates space for the arrays in the MODULE spline_galerkin
!
!--------------------------------------------------------------------
    USE spline_param
    INTEGER :: ierr
    if(Allocated(r1)) Deallocate(r1,rm1,rm2,rm3,sb,bs,db1,db2)
    ALLOCATE( r1(ns,ks), rm1(ns,ks), rm2(ns,ks), rm3(ns,ks), &
              sb(ns,ks), bs(ks,ns), db1(ns,ks), db2(ns,ks))
    r1 = 0.d0; rm1 = 0.d0; rm2 = 0.d0; sb = 0.d0; bs = 0.d0
	db1 = 0.d0; db2 = 0.d0
    END SUBROUTINE allocate_galerkin
    END MODULE spline_galerkin


!====================================================================
     MODULE spline_grid
!====================================================================
!
!    defines the values of splines at the gaussian points for each
!    interval of a grid; included in the module is the gaussian data
!    for performing integrations on the grid
!
!--------------------------------------------------------------------
     IMPLICIT NONE
     SAVE
! .. knot sequence, t(1:ns+ks)
     REAL(8), DIMENSION(:), ALLOCATABLE:: t
! .. arrays for spline values in gausian points
!
!    bsp(1:nv+1,1:ks,1:ks), bspd(1:nv+1,1:ks,1:ks,2)
!
!    bsp(i,m,ith)  - values of the i+ith-1 B-spline in interval i
!                    at gausian point m
!    bspd(i,m,ith,1|2)  - corresponding values of first and second
!                         derivatives
!    bsp(nv+1,1,.) and bspd(nv+1,1,.,.) - corresponding values at
!                                         last knot point (rmax)
     REAL(8), DIMENSION(:,:,:), ALLOCATABLE::   bsp, bsq
     REAL(8), DIMENSION(:,:,:,:), ALLOCATABLE:: bspd
! .. arrays for gaussian data
!
!    gr(1:nv;1:ks),  grm(1:nv;1:ks),  grw(1:nv;1:ks)
!
!    gr(i,m)  - gaussian points m in the interval i
!    grm(i,m) - reciprocal value of gr(i,m)
!    grw(i,m) - gaussian weights at corresponding points
     REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: gr, grm, grw
     CONTAINS
!====================================================================
      SUBROUTINE allocate_grid
!====================================================================
!
! ... allocates space of the arrays in MODULE spline_grid
!
!--------------------------------------------------------------------
      USE spline_param
      INTEGER(4) :: ierr
      if(Allocated(bsp)) Deallocate(bsp,bsq,bspd,gr,grm,grw)
      ALLOCATE(bsp(nv+1,ks,ks), bsq(nv+1,ks,ks), bspd(nv+1,ks,ks,2), &
               gr(nv,ks), grm(nv,ks), grw(nv,ks))
      bsp = 0.d0; bsq = 0.d0; bspd = 0.d0
	  gr = 0.d0; grm = 0.d0; grw = 0.d0
      END SUBROUTINE allocate_grid
    END MODULE spline_grid


!====================================================================
    MODULE spline_hl
!====================================================================
!
!   contains the spline representation of L operator
!
!--------------------------------------------------------------------
    Use spline_param
    IMPLICIT NONE
    SAVE
    INTEGER :: lh = -1    ! l-value for current L-operator
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE :: hl, vc
!   hl(1:ns,1:ks) - matrix of L-operator in the B-spline basis
!                   (in almost symmetric lower-column mode)
!   vc(1:ns,1:ks) - matrix of mass-velocity correction
   CONTAINS
!====================================================================
      SUBROUTINE allocate_hl
!====================================================================
      USE spline_param
      ALLOCATE( hl(ns,ks), vc(ns,ks))
	
	  hl = 0.d0; vc = 0.d0; lh = -2
      END SUBROUTINE allocate_hl
    END MODULE spline_hl


!====================================================================
    MODULE spline_integrals
!====================================================================
!
!   contains the B-spline representation of two-electron integral
!   rkb(i,j;i',j') in symmetric or non-symmetric column storage mode:
!
!            rkb(1:ns, 1:ns, 1:2*ks-1, 1:2*ks-1)
!
!   itype - character (rk, rk1, rk2, ...) which indicates the type
!           of integral and method of calculation for integral storing
!           in the rkb array  at the moment
!
!   krk   - multipole index for the integral
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    INTEGER(4) :: krk = -100
    CHARACTER(3) :: itype='aaa'
    REAL(8), ALLOCATABLE, DIMENSION(:,:,:,:) :: rkb
    END MODULE spline_integrals
!====================================================================
      SUBROUTINE allocate_integrals
!====================================================================
!
! ... allocates space for spline integrals
!
!--------------------------------------------------------------------
      USE spline_param
      USE spline_integrals
      INTEGER :: ierr
      if(allocated(rkb)) Deallocate (rkb)
      ALLOCATE( rkb(ns,ns,2*ks-1,2*ks-1))
	  rkb = 0.d0
      itype='bbb'
      krk=-100
      END SUBROUTINE allocate_integrals
!====================================================================
      SUBROUTINE dealloc_integrals
!====================================================================
!
! ... deallocates arrays in module "spline_integrals"
!
!--------------------------------------------------------------------
      USE spline_integrals
      if(allocated(rkb)) DEALLOCATE(rkb)
      itype='aaa'
      krk = -100
      END SUBROUTINE dealloc_integrals


!====================================================================
    MODULE spline_moments
!====================================================================
!                                                          _
!   contains moments defining as <B_i|r^k|B_j> or <B_i|r^k|B_j>
!   over an interval, where  _
!                            B = B' - B/r
!
!   These moments are used for calculating of two-electron integrals
!   according to the sell algorithm.
!
!--------------------------------------------------------------------
!
!   rkd(1:ks*ks;1:ks*ks,1:nv) -
!
!      the two-dimensional array of integrals <B_i B_j|...|B_i' B_j'>
!      over a triangle (or square) diagonal cell
!
!   rkd[1,2,3,4](1:ks*ks,1:nv) - different moments defining as
!
!     <B_i|r^k|B_j>  and <B_i|r^k|B_j>  over an interval iv
!
!   rkd, rkd1, ... differ from rkt, rkt1, ... in module spline_moments)
!   only by reduced dimensions, that increases slightly the speed of
!   calculations
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    INTEGER :: kmk = -100
    CHARACTER(3) :: mtype = 'aaa'
    REAL(8), ALLOCATABLE, DIMENSION(:,:,:) :: rkd
    REAL(8), ALLOCATABLE, DIMENSION(:,:) :: rkd1, rkd2, rkd3, rkd4
    END MODULE spline_moments
!====================================================================
      SUBROUTINE allocate_moments
!====================================================================
!
! ... allocates space for arrays in MODULE spline_moments
!
!--------------------------------------------------------------------
      USE spline_param
      USE spline_moments
      INTEGER :: ierr, jk
      if(allocated(rkd)) DEALLOCATE(rkd, rkd1,rkd2,rkd3,rkd4)
      jk = ks*ks
      ALLOCATE(rkd(jk,jk,nv), rkd1(jk,nv),rkd2(jk,nv), &
                              rkd3(jk,nv),rkd4(jk,nv))
      rkd = 0.d0; rkd1 = 0.d0; rkd2 = 0.d0; rkd3 = 0.d0; rkd4 = 0.d0
      mtype='bbb'
      kmk=-100
      END SUBROUTINE allocate_moments
!====================================================================
      SUBROUTINE dealloc_moments
!====================================================================
!
!     deallocate space in MODULE spline_moments
!
!--------------------------------------------------------------------
      USE spline_moments
      if(allocated(rkd)) DEALLOCATE(rkd, rkd1,rkd2,rkd3,rkd4)
      mtype='aaa'
      kmk=-100
      END SUBROUTINE dealloc_moments


!=======================================================================
      MODULE spline_orbitals
!=======================================================================
!
!     contains description of atomic orbitals
!     and their B-spline representation
!
!-----------------------------------------------------------------------
      IMPLICIT NONE
      SAVE
! ... LIST OF ONE-ELECTRON ORBITALS
      INTEGER(4) :: mbf = 0        ! max. number of orbitals
      INTEGER(4) :: nbf = 0        ! current number of orbitals
      INTEGER(4) :: ibf = 512      ! initial prediction of mbf
      INTEGER(4) :: jbf = 512      ! incriment for mbf
      INTEGER(4) :: iscrbf = 99    ! scratch file for reallocation
      INTEGER(4), ALLOCATABLE, DIMENSION(:) :: nbs   !  n-values
      INTEGER(4), ALLOCATABLE, DIMENSION(:) :: lbs   !  l-values
      INTEGER(4), ALLOCATABLE, DIMENSION(:) :: kbs   !  set numbers
      INTEGER(4), ALLOCATABLE, DIMENSION(:) :: mbs   !  number of splines
      INTEGER(4), ALLOCATABLE, DIMENSION(:) :: iech  !  additional pointer
      CHARACTER(4), ALLOCATABLE, DIMENSION(:) :: ebs ! spectroscopic notation
! ... B-spline expansion coefficients:
      REAL(8), ALLOCATABLE, DIMENSION(:,:) :: PBS
! ... convolution with B-overlaps:
      REAL(8), ALLOCATABLE, DIMENSION(:,:) :: QBS
! ... orbital orthogonality and AFTER conditions
      INTEGER(4) :: JBORT = 1
      INTEGER(4), ALLOCATABLE, DIMENSION(:,:) :: IBORT
! ... one-electron overlaps:
      REAL(8), ALLOCATABLE, DIMENSION(:,:) :: OBS
      END MODULE spline_orbitals
!=======================================================================
      SUBROUTINE allocate_bsorb(m)
!=======================================================================
!
!     This program allocates (deallocates) space for list of atomic
!     orbitals or reallocates it if necessary
!
!-----------------------------------------------------------------------
      USE spline_orbitals
      USE spline_param
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: m
      INTEGER(4) :: i,j,met
      if(m.le.0) then
       if(Allocated(NBS)) &
	    Deallocate (NBS,LBS,KBS,MBS,iech,EBS,IBORT,PBS,QBS,OBS)
       nbf = 0;  mbf = 0
      elseif(m.gt.mbf.or.(nbf.gt.0.and.m.ge.nbf)) then
       met = 0
       if(nbf.gt.0.and.Allocated(NBS)) then
        open(iscrbf,form='UNFORMATTED',status='SCRATCH')
        rewind(iscrbf)
        Do i=1,nbf
         write(iscrbf) nbs(i),lbs(i),kbs(i),ebs(i),mbs(i),iech(i), &
               IBORT(1:nbf,i),PBS(1:ns,i),QBS(1:ns,i),OBS(1:nbf,i)
        End do
        met = 1
       end if
       if(Allocated(nbs)) &
          Deallocate (nbs,lbs,kbs,mbs,iech,ebs,IBORT,PBS,QBS,OBS)
       mbf = m
       Allocate(nbs(mbf),lbs(mbf),kbs(mbf),ebs(mbf),mbs(1:mbf), &
                iech(1:mbf),IBORT(1:mbf,1:mbf),PBS(1:ns,1:mbf), &
                QBS(1:ns,1:mbf),OBS(1:mbf,1:mbf))
       nbs = 0; lbs = 0; kbs = 0; ebs = '****'; mbs = 0; iech = 0
       IBORT = 2; PBS = 0.d0; QBS = 0.d0; OBS = 0.d0
       if(met.gt.0) then
        rewind(iscrbf)
        Do i=1,nbf
         read(iscrbf) nbs(i),lbs(i),kbs(i),ebs(i),mbs(i),iech(i), &
               IBORT(1:nbf,i),PBS(1:ns,i),QBS(1:ns,i),OBS(1:nbf,i)
        End do
        close(iscrbf)
!        write(*,*) 'realoc_BS_orb: mbf=',mbf
       end if
      end if
      END SUBROUTINE allocate_bsorb
!=======================================================================
      INTEGER(4) FUNCTION Ifind_bsorb(n,l,k)
!=======================================================================
      USE spline_orbitals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: n,l,k
      INTEGER(4) :: i
        Ifind_bsorb=0
        Do i=1,nbf
         if(n.eq.nbs(i).and.l.eq.lbs(i).and.k.eq.kbs(i)) then
          Ifind_bsorb = i
          Return
         end if
        End do
      END FUNCTION Ifind_bsorb
!=======================================================================
      INTEGER(4) FUNCTION Jfind_bsorb(n,l,k)
!=======================================================================
      USE spline_orbitals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: n,l,k
      INTEGER(4), External :: Ifind_bsorb
      INTEGER(4) :: i
      i =  Ifind_bsorb(n,l,k)
      if(i.eq.0) then
       Write(*,*) ' Jfind_bsorb: can not find the orbital: N,L,K=',n,l,k
       Stop
      else
       Jfind_bsorb = i
      end if
      END FUNCTION Jfind_bsorb
!=======================================================================
      Integer(4) Function Iadd_bsorb(n,l,k)
!=======================================================================
!
!     adds the orbital to the list
!
!-----------------------------------------------------------------------
      USE spline_orbitals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: n,l,k
      INTEGER(4), External :: Ifind_bsorb
      CHARACTER(4), EXTERNAL :: ELF4
      INTEGER(4) :: i
      i =  Ifind_bsorb(n,l,k)
      if(i.eq.0) then
       if(nbf+1.gt.mbf) Call Allocate_bsorb(mbf+jbf)
       nbf = nbf + 1
       nbs(nbf) = n
       lbs(nbf) = l
       kbs(nbf) = k
       ebs(nbf) = ELF4(n,l,k)
       Iadd_bsorb = nbf
      else
       Iadd_bsorb = i
      end if
      END FUNCTION Iadd_bsorb


!====================================================================
    MODULE spline_slater
!====================================================================
!
!   contains arrays and variables needed for calculations of
!   Breit-Pauli integrals by direct integration in B-spline basis
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    SAVE
    INTEGER(4) :: ic1=0,ic2=0, iy1=0,iy2=0, ky=-100,kz=-100, ktx = 0
! ... the above integers serve to check the repeated calculations for
! ... arrays fc1,fc2 (ic1,ic2); fy1,fy2 (iy1,iy2), dyk,ipvtd (ky),
! ... dz,ipvtz (kz);  ktx = 3*ks-2.
    REAL(8), ALLOCATABLE, DIMENSION(:,:) :: fc1,fc2, fy1,fy2, fc
!   fc1, fc2,fy1,fy2 - serve for storing the gause-points (nv,ks)
!                      representation of radial orbitals
!   fc               - work array
    REAL(8), ALLOCATABLE, DIMENSION(:,:) :: fyk
    REAL(8), ALLOCATABLE, DIMENSION(:) :: yk
!   fyk - the gauss-point represantation of the Yk or Zk functions
!   yk  - the B-spline represantation of the Yk or Zk functions
    REAL(8), ALLOCATABLE, DIMENSION(:,:) :: dyk, dzk
    INTEGER(4), ALLOCATABLE, DIMENSION(:) :: ipvtd, ipvtz
!   dyk(ktx,ns),ipvtd(ns) - factorization of the Yk operator:
!                           Yk --> d^2/dr^2 - k(k+1)/r^2
!   dzk(ktx,ns),ipvtz(ns) - factorization of the Zk operator:
!                           Yk --> d/dr + k/r
    END MODULE spline_slater
!====================================================================
      SUBROUTINE allocate_slater
!====================================================================
!
!     allocates (reallocate) space for arrais in MODULE spline_slater
!
!--------------------------------------------------------------------
      USE spline_param
      USE spline_slater
      INTEGER :: ierr
      ktx = 3*ks-2
      if(Allocated(fc1)) Deallocate(fc1,fc2,fy1,fy2,fc, yk,fyk, &
                                    dyk,ipvtd, dzk,ipvtz)
      ALLOCATE(fc1(nv,ks), fc2(nv,ks), fy1(nv,ks), fy2(nv,ks),  &
               fc(nv,ks), yk(ns), fyk(nv,ks),                   &
               dyk(ktx,ns),ipvtd(ns),dzk(ktx,ns),ipvtz(ns))
	  fc1 = 0.d0; fc2 = 0.d0; fy1 = 0.d0; fy2 = 0.d0
	  fc = 0.d0; yk = 0.d0; fyk = 0.d0		
      ic1=0; ic2=0; iy1=0; iy2=0; ky=-100; kz=-100
      END SUBROUTINE allocate_slater
!====================================================================
      SUBROUTINE dealloc_slater
!====================================================================
!
!     deallocates space for arrais in MODULE spline_slater
!
!--------------------------------------------------------------------
      USE spline_slater
      if(Allocated(fc1)) Deallocate(fc1,fc2,fy1,fy2,fc, yk,fyk, &
                                    dyk,ipvtd, dzk,ipvtz)
      ic1=0; ic2=0; iy1=0; iy2=0; ky=-100; kz=-100; ktx = 0
      END SUBROUTINE dealloc_slater


!=======================================================================
    Real(8) FUNCTION azl(z,h,ks,lp)
!=======================================================================
!
!   Value of B_(lp+1)/r^lp at r = 0 where lp = l+1
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: ks,lp
    REAL(8), INTENT(in) :: z,h
    INTEGER(4) :: j
    REAL(8) :: c
    IF (lp < ks ) THEN
      azl = 1.d0
      c = z/h
      do j = 1,lp
        azl = (azl*c*(ks-j))/(j*j)
      end do
    ELSE
      azl = 0.d0
    END IF
   END FUNCTION azl


!=======================================================================
    SUBROUTINE bav(ns,ks,b,v,y,type,side)
!=======================================================================
!
!   Computes  y = B * v    or   y = v * B     (side =  'r' or 'l')
!
!   where b is a symmetric or non-symmetric banded matrix
!   (type = 's' or 'n')
!
!   and  v, y  are vectors
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       ks      the number of diagonals
!       ns      the order of the matrix
!       b       the  banded matrix in column (upper) storage mode
!       v       vector
!
!   on exit
!   -------
!       y       y = b*v
!
!-----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: ns, ks
      REAL(KIND=8), DIMENSION(ns), INTENT(IN) :: v
      REAL(KIND=8), DIMENSION(ns), INTENT(out) :: y
      REAL(KIND=8), DIMENSION(ns,*), INTENT(IN) :: b
      CHARACTER(LEN=1) :: type, side
      ! .. Local variables
      INTEGER :: i, j, ip, imin, imax
      if(type.eq.'s') then
        do i=1,ns
          y(i) = b(i,1)*v(i)
        end do
        do ip = 2,ks
          do i = 1,ns-ip+1
            j = i+ip-1
            y(i) = y(i) + b(i,ip)*v(j)
            y(j) = y(j) + b(i,ip)*v(i)
          end do
        end do
      elseif(type.eq.'n'.and.side.eq.'r') then
        y = 0.d0
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
            j = i+ip-ks
            y(i) = y(i) + b(i,ip)*v(j)
          end do
        end do
      elseif(type.eq.'n'.and.side.eq.'l') then
        y = 0.d0
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
            j = i+ip-ks
            y(j) = y(j) + b(i,ip)*v(i)
          end do
        end do
      end if
      END SUBROUTINE bav


!======================================================================
      SUBROUTINE BCORE
!======================================================================
!
!     COMPUTES THE ENERGY OF THE COMMON CLOSED SHELLS  (CORE)
!
!----------------------------------------------------------------------
      USE spline_atomic, nclosd => kclosd
      USE spline_orbitals, L => LBS
      IMPLICIT NONE
      INTEGER :: I,J,K
      REAL(8) :: SUMI, SUMJ, CA, CB, CN, TI, TIJ, ck,cl, c1,c2, &
                 TK1,TK2,TK3, UK1,UK2, SN,SN2
      REAL(8), EXTERNAL :: ZCB, BHL, RKy, NKy, TKy
      Real(8), Parameter :: zero = 0.d0, one = 1.d0, two = 2.d0
      EC = zero
      DO I = 1,NCLOSD
       SUMI = 4*L(I)+2
       TI = RKy(I,I,I,I,0)
       DO K = 2,2*L(I),2
        CA = ZCB(L(i),K,L(i)) * (2*L(i)+1)/(4*L(i)+1)
        TI = TI - CA*RKy(I,I,I,I,k)
       END DO
       EC = EC + SUMI*((SUMI-1)*TI - BHL(I,I)) / two
       DO J = 1,I-1
         SUMJ = 4*L(J)+2
         TIJ = RKy(I,J,I,J,0)
         DO K=IABS(L(I)-L(J)),L(I)+L(J),2
           CB = ZCB(L(i),K,L(j))/two
           TIJ = TIJ - CB*RKy(I,J,J,I,k)
         END DO
         EC = EC + SUMI*SUMJ*TIJ
       END DO
      END DO
!----------------------------------------------------------------------
!                                                     o-o  interaction:
      if(ioo.eq.0) Return
      DO I = 1,NCLOSD
        if(L(i).eq.0) Cycle
        SUMI = 4*L(I)+2
        TI = 0.d0
        if(L(I).eq.1) TI = +  8.D0/  5.D0  * NKy(I,I,I,I,0)
        if(L(I).eq.2) TI = + 56.D0/ 21.D0  * NKy(I,I,I,I,0) &
                           + 16.D0/ 21.D0  * NKy(I,I,I,I,2)
        if(L(I).eq.3) TI = + 48.D0/ 13.D0  * NKy(I,I,I,I,0) &
                           + 16.D0/ 13.D0  * NKy(I,I,I,I,2) &
                           + 80.D0/143.D0  * NKy(I,I,I,I,4)
        DO K = 2,2*L(I),2
         CA = ZCB(L(i),K,L(i)) * (2*L(i)+1)/(4*L(i)+1)
         SN = NKy(i,i,i,i,k)
         SN2 = NKy(i,i,i,i,k-2)
         c1 =-one*(k+3)/(k+1)/(k+k+3)
         c2 = one*(k-2)/k/(k+k-1)
         TI = TI + CA*(c1*SN-c2*SN2)
        END DO
        EC = EC + SUMI*(SUMI-1)*TI/two
        DO J = 1,I-1
         if(L(i).eq.0) Cycle
         SUMJ = 4*L(J)+2
         TIJ = zero
         DO K=IABS(L(I)-L(J)),L(I)+L(J),2
           CB = ZCB(L(i),K,L(j))
           SN = NKy(i,j,j,i,k)
           CN = CB*(L(i)+L(j)+k+2)*(L(i)+L(j)-k)   &
                  *(L(i)-L(j)+k+1)*(L(j)-L(i)+k+1) &
                  /(k+1)/(k+2)
           TIJ = TIJ + CN*SN
           if(k.eq.0) Cycle
           TK1=TKy(i,j,j,i,k+1)-TKy(i,j,j,i,k-1)
           TK2=TKy(j,j,i,i,k+1)-TKy(j,j,i,i,k-1)
           TK3=TKy(i,i,j,j,k+1)-TKy(i,i,i,i,k-1)
           UK1 = TK1 + TK2
           UK2 = TK1 + TK3
           ck = k*(k+1)
           cl = L(i)*(L(i)+1)-L(j)*(L(j)+1)
           c1 = cl - ck
           c2 =-cl - ck
           TIJ = TIJ + CB*(ck*TK1 + (c1*UK1 + c2*UK2)/two)
           SN2 = NKy(i,j,j,i,k-2)
           cn = CB*c1*c2/two
           c1 =-cn*(k+3)/(k+1)/(k+k+3)
           c2 = cn*(k-2)/k/(k+k-1)
           TIJ = TIJ + c1*SN + c2*SN2
         END DO
         EC = EC + SUMI*SUMJ*TIJ
       END DO
      END DO
      END SUBROUTINE BCORE


!======================================================================
      Function BHL(i,j)
!======================================================================
!
!       <P_i| L |P_j> with inclusion of rel.shift if rel = .true.
!
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_hl
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: i,j
      REAL(KIND=8) :: BHL
      REAL(KIND=8), EXTERNAL :: BVMV
      if (iabs(LBS(i)-LBS(j)) .NE. 0) Stop ' HL:  LI <> LJ'
      Call HLM (lbs(i))
      BHL = BVMV(ns,ks,hl,'a',pbs(1,i),pbs(1,j))
    END FUNCTION BHL


!=======================================================================
    SUBROUTINE bhwf(n,l,z,coef)
!=======================================================================
!
!   computes the spline expansion coefficients for hydrogenic radial
!   function for quantum numbers (n,l) and effective nuclear charge z.
!
!   SUBROUTINES called:
!       vhwf, vinty, and dpbsl (from LINPACK)
!
!   Calling sequence:
!
!            bhwf
!           ------
!          /  |   \
!       vhwf vinty dpbsl
!        ||        /   \
!       hnorm    daxpy ddot
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       n,l     orbital quantum numbers
!       z       effective nuclear charge
!
!   on exit
!   -------
!       coef    the spline coefficients defining the expansion of
!               the radial function P(nl;r)
!
!-----------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n, l
    REAL(KIND=8), INTENT(IN) :: z
    REAL(KIND=8), DIMENSION(ns), INTENT(OUT) :: coef
    ! .. Local variables
    INTEGER :: m, ierr
    REAL(8), DIMENSION(nv,ks) :: yr, bsl(ks,ns)
      ! .. obtain the values of the radial function
      !    at all the gaussian points
      ! .. and multiply by the gaussian weights
    do m=1,ks
      CALL vhwf(n,l,z,nv,gr(1,m),yr(1,m))
      yr(:,m) = yr(:,m)*grw(:,m)
    end do
    ! .. form the vector of inner products of the radial function and the
    ! .. spline basis functions
    CALL vinty(yr,coef)
    ! .. apply the boundary condition at the origin
    Call zfacsb(bsl,l)
    coef(1:l+1)=0.d0
    ! .. solve the system of equations bs coef = vy for coef
!   Call dpbsl(bsl,ks,ns,ks-1,coef)   ! LINPACK
    Call dpbtrs ('U',ns,ks-1,1,bsl,ks,coef,ns,ierr)
    if(ierr.ne.0) Stop 'bhwf:  dpbtrs (LAPACK) failed'
  END SUBROUTINE bhwf
!====================================================================
    SUBROUTINE zfacsb(bsl,l)
!====================================================================
!
!   Sets up the overlap bs which is a transpose of sb, <B_i,B_j>,
!   with the correct boundary condition at r=0 and factorizes bs.
!
!   SUBROUTINES called:
!       dpbfa (from LINPACK)
!
!--------------------------------------------------------------------
    USE spline_param
    USE spline_galerkin
    IMPLICIT NONE
    INTEGER, INTENT(in) :: l
    REAL(KIND=8), DIMENSION(ks,ns), INTENT(out) :: bsl
    ! .. local variables
    INTEGER :: i,j,ierr
    ! .. copy the array, converting to row oriented band storage mode
    bsl = TRANSPOSE(sb)
    ! .. apply boundary condition at r=0
    do i = 1,l+1
     bsl(ks,i) = 1.d0
     do j = 1,ks-1
       bsl(j,ks-j+i)=0.d0
     end do
    end do
!    CALL dpbfa(bsl,ks,ns,ks-1,ierr)
!    if (ierr /= 0 ) STOP 'facsb: dpbfa (LINPACK) failed'
    Call DPBTRF('U',ns,ks-1,bsl,ks,ierr)
    if (ierr.ne.0)  Stop 'facsb: dpbtrf (LAPACK) failed'
  END SUBROUTINE zfacsb
!=======================================================================
    SUBROUTINE vhwf(n,l,z,nr,r,vh)
!=======================================================================
!
!   This program returns the vector of values, vh(i), of a normalized
!   hydrogenic function with nuclear charge z and quantum numbers (n,l)
!   at values of the radius, r(i),  i=1,nr.
!
!   Calls:  hnorm
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       n     principal quantum number
!       l     angular quantum number
!       z     Nuclear charge
!       nr    number of points in the vector
!       r     values at which radial function is to be evaluated, in
!             increasing order
!
!   on exit
!   -------
!       vh    values of the hydrogenic radial functions
!
!-----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n, l, nr
    REAL(8), INTENT(IN) :: z
    REAL(8), DIMENSION(nr), INTENT(IN) :: r
    REAL(8), DIMENSION(nr), INTENT(OUT) :: vh
    ! .. Local variables
    INTEGER :: k, i, nm
    REAL(8) :: a, b, c, factor
    REAL(8), DIMENSION(nr) :: w, p
    REAL(8), EXTERNAL :: hnorm1
    k = n-l-1
    if(k.lt.0) Stop ' vhwf:  n < l+1 '
    factor =  hnorm1(n,l,z)       ! .. gets the normalization 'factor'
    w = -2.D0*z*r/n  ! .. store the argument of the exponential factor
    ! .. to avoid underlow, determine point at which function will be zero
    ! .. Note that exp(-150) = 0.7175 10**-65
    nm = nr
    do
      if (w(nm) < -150.D0 .AND. nm /= -1) then
        vh(nm) = 0.D0
        nm = nm-1
      else
        EXIT
      end if
    end do
    ! .. Initialize the recurrence relation for each value of r(i)
    p(1:nm) = 1.D0
    a = 1.D0
    b = k
    c = n+l
    ! .. Apply the recurrence relation when k is positive
    do i = 1,k
      p(1:nm) = 1.D0+a/b*p(1:nm)/c*w(1:nm)
      a = a+1.D0
      b = b-1.D0
      c = c-1.D0
    end do
    ! .. Multiply the factor by the exponential
    vh(1:nm) = factor*p(1:nm)*EXP(w(1:nm)/2.D0)*(-w(1:nm))**(l+1)
   END SUBROUTINE vhwf
!====================================================================
    REAL(8) FUNCTION hnorm1(n,l,Z)
!====================================================================
!
!   returns the value of the normalization constant for an
!   hydrogenic function with nuclear charge z, and orbital
!   quantum numbers (n,l)
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: n,l
    REAL(8), INTENT(in) :: z
    ! .. local variables
    INTEGER :: m, i
    REAL(KIND=8) :: a, b, d, t
    m = l+l+1
    a = n+l
    b = m
    t = a
    d = b
    m = m-1
    if ( m > 0) then
      do  i = 1,m
        a = a-1.d0
        b = b-1.d0
        t = t*a
        d = d*b
      end do
    end if
    hnorm1 = SQRT(z*t)/(n*d)
  END FUNCTION hnorm1


!=======================================================================
    FUNCTION bvalu2 (t, bcoef, ns, ks, x, jderiv)
!=======================================================================
!
!   This routine is a modification of de Boor's bvalue routine, modified
!   to return the value at right endpoint continuous from the left,
!   instead of 0. It assumes the usual knot multiplicity ks at the right
!   endpoint.
!
!   It calculates the value at  x of the jderiv-th derivative of spline
!   from b-representation. The spline is taken to be continuous from the
!   right.
!
!   SUBROUTINES contained:
!       interv
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!
!       t      knot sequence, of length  ns+ks, assumed nondecreasing.
!       bcoef  coefficient sequence, of length  ns .
!       ns     length of  bcoef, assumed positive.
!       ks     order of the spline .
!
!             . . . W A R N I N G . . .
!       The restriction  ks <= kmax (=15)  is imposed
!       arbitrarily by the parameter statement defining dimensions
!       for aj, dm, dp  below, but is  NEVER CHECKED.
!
!       x      the point at which to evaluate the spline.
!       jderiv integer giving the order of the derivative to be evaluated
!              ASSUMED to be zero or positive.
!
!   on exit
!   -------
!   bvalu2 - the value of the (jderiv)-th derivative of  f  at  x .
!
!   method
!   ------
!     the nontrivial knot interval  (t(i),t(i+1))  containing  x  is lo-
!   cated with the aid of  INTERV. the  ks  b-coeffs of  f  relevant for
!   this interval are then obtained from  bcoef (or taken to be zero if
!   not explicitly available) and are then differenced  jderiv  times to
!   obtain the b-coeffs of  (d**jderiv)f  relevant for that interval.
!   precisely, with  j = jderiv, we have from x.(12) of the text that
!
!           (d**j)f  =  sum ( bcoef(.,j)*b(.,ks-j,t) )
!
!   where
!                  / bcoef(.),                     ,  j = 0
!                  /
!   bcoef(.,j)  =  / bcoef(.,j-1) - bcoef(.-1,j-1)
!                  / ----------------------------- ,  j > 0
!                  /    (t(.+ks-j) - t(.))/(ks-j)
!
!   then, we use repeatedly the fact that
!
!     sum ( a(.)*b(.,m,t)(x) )  =  sum ( a(.,x)*b(.,m-1,t)(x) )
!   with
!                  (x - t(.))*a(.) + (t(.+m-1) - x)*a(.-1)
!     a(.,x)  =    ---------------------------------------
!                  (x - t(.))      + (t(.+m-1) - x)
!
!   to write  (d**j)f(x)  eventually as a linear combination of b-splines
!   of order  1 , and the coefficient for  b(i,1,t)(x)  must then
!   be the desired number  (d**j)f(x). (see x.(17)-(19) of text).
!
!   current fortran standard makes it impossible to specify the length
!   of t  precisely without the introduction of otherwise superfluous
!   additional arguments.
!
!-----------------------------------------------------------------------
    IMPLICIT NONE
    REAL(8) :: bvalu2
    INTEGER(4), INTENT(IN) :: ns, ks, jderiv
    REAL(8), INTENT(IN) :: x
    REAL(8), DIMENSION(ns), INTENT(IN) :: bcoef
    REAL(8), DIMENSION(ns+ks), INTENT(IN) :: t
    ! ..  local variable
    REAL(8), DIMENSION(ks) :: aj, dm, dp        !  ???
    REAL(8) :: fkmj
    INTEGER(4) :: i, mflag, km1, jcmin, imk, nmi, jcmax, jc, &
                  j, jj, kmj, ilo
    bvalu2 = 0.d0
    IF (jderiv >= ks) RETURN
! ... find  i  such that 1 <= i < ns+ks  and  t(i) < t(i+1) and
! ... t(i) <= x < t(i+1) . if no such i can be found,  x  lies
! ... outside the support of  the spline  f  and  bvalu2 = 0.
! ... (the asymmetry in this choice of i makes f rightcontinuous)
    IF( x /= t(ns+1) .OR. t(ns+1) /= t(ns+ks) ) THEN
      CALL interv1(t,ns+ks,x, i, mflag)
      IF (mflag /= 0) RETURN
    ELSE
      i = ns
    END IF
! ... if ks = 1 (and jderiv = 0), bvalu2 = bcoef(i).
    km1 = ks - 1
    IF ( km1 <= 0 ) THEN
      bvalu2 = bcoef(i)
      RETURN
    END IF
! ... store the ks b-spline coefficients relevant for the knot interval
! ... (t(i),t(i+1)) in aj(1),...,aj(ks); compute dm(j) = x - t(i+1-j),
! ... dp(j) = t(i+j) - x, j=1,...,ks-1. Set any of the aj not obtainable
! ... from input to zero. set any t.s not obtainable equal to t(1) or
! ... to t(ns+ks) appropriately.
    jcmin = 1
    imk = i - ks
    IF (imk < 0) THEN
      jcmin = 1 - imk
      do j=1,i
        dm(j) = x - t(i+1-j)
      end do
      do j=i,km1
        aj(ks-j) = 0.
        dm(j) = dm(i)
      end do
    ELSE
      do j=1,km1
        dm(j) = x - t(i+1-j)
      end do
    END IF
    jcmax = ks
    nmi = ns - i
    IF (nmi < 0) THEN
      jcmax = ks + nmi
      do j=1,jcmax
        dp(j) = t(i+j) - x
      end do
      do j=jcmax,km1
        aj(j+1) = 0.
        dp(j) = dp(jcmax)
      end do
    ELSE
      do j=1,km1
        dp(j) = t(i+j) - x
      end do
    END IF
      do jc=jcmin,jcmax
        aj(jc) = bcoef(imk + jc)
      end do
! ... difference the coefficients  jderiv  times.
    IF (jderiv /= 0) THEN
      DO j=1,jderiv
        kmj = ks-j
        fkmj = kmj
        ilo = kmj
        DO jj=1,kmj
          aj(jj) = ((aj(jj+1) - aj(jj))/(dm(ilo) + dp(jj)))*fkmj
          ilo = ilo - 1
        END DO
      END DO
    END IF
! ... compute value at  x  in (t(i),t(i+1)) of jderiv-th derivative,
! ... given its relevant b-spline coeffs in aj(1),...,aj(ks-jderiv).
    IF (jderiv /= km1) THEN
      DO j=jderiv+1,km1
        kmj = ks-j
        ilo = kmj
        DO jj=1,kmj
          aj(jj) = (aj(jj+1)*dm(ilo) + aj(jj)*dp(jj))/(dm(ilo)+dp(jj))
          ilo = ilo - 1
        END DO
      END DO
    END IF
    bvalu2 = aj(1)
  END FUNCTION bvalu2
!=======================================================================
      Subroutine INTERV1 ( xt, lxt, x, left, mflag )
!=======================================================================
!
!     Computes  left = max( i ; 1 <= i <= lxt  .and.  xt(i) <= x )
!     which is the interval containing x .
!
!     A reformatted version of the de Boor routine
!
!      on entry
!      --------
!
!      xt  a real sequence, of length lxt, assumed to be nondecreasing
!      lxt number of terms in the sequence xt .
!      x   the point whose location with respect to the sequence xt is
!          to be determined.
!
!      on exit
!      -------
!      left, mflag   integers, whose values are
!         1     -1   if               x .lt.  xt(1)
!         i      0   if   xt(i)  .le. x .lt. xt(i+1)
!        lxt     1   if  xt(lxt) .le. x
!
!      In particular,  mflag = 0 is the 'usual' case.  mflag .ne. 0
!      indicates that  x  lies outside the halfopen interval
!      xt(1) .le. y .lt. xt(lxt) . the asymmetric treatment of the
!      interval is due to the decision to make all pp functions cont-
!      inuous from the right. (left - ?)
!
!      ...  m e t h o d  ...
!
!  The program is designed to be efficient in the common situation where
!  it is called repeatedly, with  x  taken from an increasing or decrea-
!  sing sequence. this will happen, e.g., when a pp function is to be
!  graphed. the first guess for  left  is therefore taken to be the val-
!  ue returned at the previous call and stored in the  l o c a l  varia-
!  ble  ilo . a first check ascertains that  ilo .lt. lxt (this is nec-
!  essary since the present call may have nothing to do with the previ-
!  ous call). then, if  xt(ilo) .le. x .lt. xt(ilo+1), we set  left =
!  ilo  and are done after just three comparisons.
!     otherwise, we repeatedly double the difference  istep = ihi - ilo
!  while also moving  ilo  and  ihi  in the direction of  x , until
!                      xt(ilo) .le. x .lt. xt(ihi) ,
!  after which we use bisection to get, in addition, ilo+1 = ihi .
!  left = ilo  is then returned.
!-----------------------------------------------------------------------
      integer left,lxt,mflag,   ihi,ilo,istep,middle
      double precision x,xt(lxt)
      data ilo /1/
      ihi = ilo + 1
      if (ihi .lt. lxt)                 go to 20
         if (x .ge. xt(lxt))            go to 110
         if (lxt .le. 1)                go to 90
         ilo = lxt - 1
         ihi = lxt
   20 if (x .ge. xt(ihi))               go to 40
      if (x .ge. xt(ilo))               go to 100
!     ... now x .lt. xt(ilo) . decrease  ilo  to capture  x
   30 istep = 1
   31    ihi = ilo
         ilo = ihi - istep
         if (ilo .le. 1)                go to 35
         if (x .ge. xt(ilo))            go to 50
         istep = istep*2
                                        go to 31
   35 ilo = 1
      if (x .lt. xt(1))                 go to 90
                                        go to 50
!     ... now x .ge. xt(ihi) . increase  ihi  to capture  x
   40 istep = 1
   41    ilo = ihi
         ihi = ilo + istep
         if (ihi .ge. lxt)              go to 45
         if (x .lt. xt(ihi))            go to 50
         istep = istep*2
                                        go to 41
   45 if (x .ge. xt(lxt))               go to 110
      ihi = lxt
!     ... now xt(ilo) .le. x .lt. xt(ihi) . narrow the interval
   50 middle = (ilo + ihi)/2
      if (middle .eq. ilo)              go to 100
!     note. it is assumed that middle = ilo in case ihi = ilo+1 .
      if (x .lt. xt(middle))            go to 53
         ilo = middle
                                        go to 50
   53    ihi = middle
                                        go to 50
!    ... set output and return
   90 mflag = -1
      left = 1
                                        return
  100 mflag = 0
      left = ilo
                                        return
  110 mflag = 1
      left = lxt
                                        return
      End Subroutine INTERV1


!=====================================================================
    FUNCTION bvmv(n,k,array,type,x,y)
!=====================================================================
!
!   Returns bvmv = <x,array y> for the band array.
!
!   The original size of array is n*n. The bandwidth of array is 2k-1
!   for the non-symmetric case, and is k for symmetric case.
!   The lower-band column storage mode is assumed.
!---------------------------------------------------------------------
!
!   on entry
!   --------
!       n      the leading dimension.
!       k      the band width.
!       array  a banded matrix in the lower-band column storage mode.
!              Its element (i,j) represents the element (i,i+j-k) of
!              the original matrix. For a symmetric matrix, only the
!              lower diagonals are needed.
!       type   'g' for general;
!              's' for symmetric;
!              'a' for "almost"  symmetric, as db2
!       x      vector with length n.
!       y      vector with length n.
!
!----------------------------------------------------------------------
    REAL(KIND=8) :: bvmv, ans
    INTEGER, INTENT(in) :: n, k
    CHARACTER(LEN=1), INTENT(in) :: type
    REAL(KIND=8), DIMENSION(n,*), INTENT(in) :: array
    REAL(KIND=8), DIMENSION(n), INTENT(in) :: x, y
    ! .. Local variables
    INTEGER :: i,j,jp,kp
    bvmv = 0.d0
    if ( type /= 'g') then
      ! .. symmetric
      do jp = 1,k-1
        do i = k+1-jp,n
          j = i+jp-k
          bvmv = bvmv + array(i,jp) * (x(i)*y(j) + x(j)*y(i))
        end do
      end do
      ! .. make correction for 'a' (almost symmetric)
      if (type == 'a')  &
          bvmv = bvmv + x(n-1)*y(n)*(array(1,1)-array(n,k-1))
    else
      do jp = 1,k-1
        do i = k-jp+1,n
          j = i+jp-k
          kp = 2*k-jp
          ans = ans + array(i,jp)*x(i)*y(j)
          ans = ans + array(j,kp)*x(j)*y(i)
        end do
      end do
    end if
    ! .. add central diagonal
    bvmv = bvmv + SUM(array(:,k)*x(:)*y(:))
  END FUNCTION bvmv


!=======================================================================
    SUBROUTINE bxv(k,n,b,v,y)
!=======================================================================
!
!   Computes   y = b * v    where b is a symmetric, banded matrix,
!   in lower-band storage mode,  and v, y are vectors.
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       k       the number of diagonals
!       n       the order of the matrix
!       b       the symmetric, banded matrix in column storage mode
!       v       vector
!
!   on exit
!   -------
!       y       y = b*v
!
!-----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n, k
    REAL(KIND=8), DIMENSION(n), INTENT(IN) ::v
    REAL(KIND=8), DIMENSION(n,k), INTENT(IN) ::b
    REAL(KIND=8), DIMENSION(n), INTENT(out) :: y
    ! .. Local variables
    INTEGER :: i, j, jp
! ...   contribution from central diagonal (jp=k)
        Do i=1,n
          y(i) = b(i,k)*v(i)
        End do
! ...   off diagonal
        Do jp = 1,k-1
         Do i = k-jp+1,n
          j = i-k+jp
          y(i) = y(i) + b(i,jp)*v(j)             ! sub_diagonals
          y(j) = y(j) + b(i,jp)*v(i)             ! super-diagonals
         End do
        End do
  END SUBROUTINE bxv


!======================================================================
     Subroutine BZK (j1,j2,k,kk)
!======================================================================
!
!    Solves the following differential equation by the
!    spline-Galerkin method:
!
!        (d + k/r) zk(r) = r^kk * P_j1(r) * P_j2(r),
!
!    with boundary conditionas zk(0) = 0 if k >= 0,
!    and  dz/dr (0) = 0 if k = -1 (for Nk integrals)
!
!    Calls:  FACDZK, YVAL, VINTY, dgbtrf (LAPACK) or dgbsl (LINPACK)
!
!    on entry
!    --------
!    k      the order of zk
!    kk     defines right side of equation
!    j1,j2  orbital pointers
!
!    on exit
!    -------
!    yk   B-spline reprezantation of Zk
!    fyk  Gauss-point reprezantation of Zk
!--------------------------------------------------------------------
     USE spline_param
     USE spline_grid
     USE spline_slater
     USE spline_orbitals, p => pbs
     IMPLICIT NONE
     INTEGER, INTENT(in) :: j1,j2,k,kk
     Integer(4) :: info
     if(kz.ne.k) Call FACDZK (ktx,k,dzk,ipvtz);  kz=k
! ... create the numerical values of the orbitals on the grid
     if (iy1 .ne. j1) then
       Call YVAL (0,0,0,p(1,j1),fy1);  iy1=j1
     end if
     if (iy2 .ne. j2) then
       Call YVAL (0,0,0,p(1,j2),fy2);  iy2=j2
     end if
! ... set up the array of yk(i) = INTEGRAL 'r^kk*fc1(r)fc2(r)*B_i(r)'
      if(kk.eq.0) then
         fc = grw*fy1*fy2        ! Nk integrals
      elseif(kk.eq.1) then
         fc = gr*grw*fy1*fy2     ! Vk integral
      else
         Stop ' BZK: kk is wrong '
      end if
      Call Vinty(fc,yk)
! ... boundary conditions:
      yk(1)=0.d0;  if(k.eq.-1) yk(2)=0.d0   ! for Nk with k=-1
! ... solve the matrix equation
!     CALL dgbsl(dzk,ktx,ns,ks-1,ks-1,ipvtz,yk,0) ! LINPACK
      Call DGBTRS ('N',ns,ks-1,ks-1,1,dzk,3*ks-2,ipvtz,yk,ns,info)
      if( info .ne. 0 ) Stop 'BZK: dgbtrs (LAPACK) failed'
! ... evaluates the function (1/r)zk(r) at all the gaussian points
      Call YVAL (0,0,-1,yk,fyk)
      END SUBROUTINE BZK


!======================================================================
      Subroutine convol(ns,ks,a,d,icase,sym_i,sym_j)
!======================================================================
!
!    convolutes the rkb(i,j,i',j') array of spline integrals
!    with density matrix d(:,:)
!
!    results in array a
!
!    icase =  1  - convolution other 2 and 4 variables, RK(.a;.b)
!             2  - convolution other 1 and 3 variables, RK(a.;b.)
!             3  - convolution other 2 and 3 variables, RK(.a;b.)
!             4  - convolution other 1 and 4 variables, RK(a.;.b)
!
!    sym_i  ->  symmetry in respect of i,i' variables ('s', 'n')
!    sym_j  ->  symmetry in respect of j,j' variables ('s', 'n')
!
!----------------------------------------------------------------------
      USE spline_integrals, ONLY: rkb
      IMPLICIT NONE
      INTEGER, INTENT(in) :: ns,ks,icase
      CHARACTER(1), INTENT(in) :: sym_i,sym_j
      REAL(8), DIMENSION(ns,*), INTENT(in ) :: d
      REAL(8), DIMENSION(ns,*), INTENT(out) :: a
      INTEGER :: i,j, ip,jp, imin,imax, jmin,jmax, ii,jj
      REAL(KIND=8) :: c
      if(icase.gt.2) a(1:ns,1:ns) = 0.d0
      if(sym_i.eq.'s'.and.sym_j.eq.'s'.and.icase.eq.1) then
        do ip = 1,ks
          do i = 1,ns-ip+1
            c = 0.d0
            do jp = 1,ks
              do j = 1,ns-jp+1
                c = c + d(j,jp)*rkb(i,j,ip,jp)
              end do
            end do
            a(i,ip) = c
          end do
        end do
      elseif(sym_i.eq.'s'.and.sym_j.eq.'s'.and.icase.eq.2) then
        do ip = 1,ks
          do i = 1,ns-ip+1
            c = 0.d0
            do jp = 1,ks
              do j = 1,ns-jp+1
                c = c + d(j,jp)*rkb(j,i,jp,ip)
              end do
            end do
            a(i,ip) = c
          end do
        end do
      elseif(sym_i.eq.'n'.and.sym_j.eq.'n'.and.icase.eq.1) then
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
            c = 0.d0
            do jp = 1,ks+ks-1
              jmin=max( 1, 1 + ks-jp)
              jmax=min(ns,ns + ks-jp)
              do j = jmin,jmax
                  c = c + d(j,jp)*rkb(i,j,ip,jp)
              end do
            end do
            a(i,ip) = c
          end do
        end do
      elseif(sym_i.eq.'n'.and.sym_j.eq.'n'.and.icase.eq.2) then
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
            c = 0.d0
            do jp = 1,ks+ks-1
              jmin=max( 1, 1 + ks-jp)
              jmax=min(ns,ns + ks-jp)
              do j = jmin,jmax
                  c = c + d(j,jp)*rkb(j,i,jp,ip)
              end do
            end do
            a(i,ip) = c
          end do
        end do
      elseif(sym_i.eq.'n'.and.sym_j.eq.'s'.and.icase.eq.1) then
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
            c = 0.d0
            do jp = 1,ks
              do j = 1,ns-jp+1
                  c = c + d(j,jp)*rkb(i,j,ip,jp)
              end do
            end do
            a(i,ip) = c
          end do
        end do
      elseif(sym_i.eq.'n'.and.sym_j.eq.'s'.and.icase.eq.2) then
        do jp = 1,ks
          do j = 1,ns-jp+1
            c = 0.d0
            do ip = 1,ks+ks-1
              imin=max( 1, 1 + ks-ip)
              imax=min(ns,ns + ks-ip)
              do i = imin,imax
                  c = c + d(i,ip)*rkb(i,j,ip,jp)
              end do
            end do
            a(j,jp) = c
          end do
        end do
      elseif(sym_i.eq.'s'.and.sym_j.eq.'n'.and.icase.eq.2) then
        do jp = 1,ks+ks-1
          jmin=max( 1, 1 + ks-jp)
          jmax=min(ns,ns + ks-jp)
          do j = jmin,jmax
            c = 0.d0
            do ip = 1,ks
              do i = 1,ns-ip+1
                  c = c + d(i,ip)*rkb(i,j,ip,jp)
              end do
            end do
            a(j,jp) = c
          end do
        end do
      elseif(sym_i.eq.'s'.and.sym_j.eq.'n'.and.icase.eq.1) then
        do ip = 1,ks
          do i = 1,ns-ip+1
            c = 0.d0
            do jp = 1,ks+ks-1
              jmin=max( 1, 1 + ks-jp)
              jmax=min(ns,ns + ks-jp)
              do j = jmin,jmax
                  c = c + d(j,jp)*rkb(i,j,ip,jp)
              end do
            end do
            a(i,ip) = c
          end do
        end do
    elseif(sym_i.eq.'s'.and.sym_j.eq.'s'.and.icase.eq.3) then
      do jp = 1,ks
        do j = 1,ns-jp+1
          jj = j+jp-1
          do ip = 1,ks
            do i = 1,ns-ip+1
              ii = i+ip-1
              c = rkb(i,j,ip,jp)
                                a( i,jj) = a( i,jj) + c*d(ii, j)
       if(ip.gt.1)              a(ii,jj) = a(ii,jj) + c*d( i, j)
       if(jp.gt.1)              a( i, j) = a( i, j) + c*d(ii,jj)
       if(ip.gt.1.and.jp.gt.1)  a(ii, j) = a(ii, j) + c*d( i,jj)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'s'.and.sym_j.eq.'s'.and.icase.eq.4) then
      do jp = 1,ks
        do j = 1,ns-jp+1
          jj = j+jp-1
          do ip = 1,ks
            do i = 1,ns-ip+1
              ii = i+ip-1
              c = rkb(i,j,ip,jp)
                                a(ii, j) = a(ii, j) + c*d( i,jj)
       if(ip.gt.1)              a( i, j) = a( i, j) + c*d(ii,jj)
       if(jp.gt.1)              a(ii,jj) = a(ii,jj) + c*d( i, j)
       if(ip.gt.1.and.jp.gt.1)  a( i,jj) = a( i,jj) + c*d(ii, j)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'n'.and.sym_j.eq.'n'.and.icase.eq.3) then
      do jp = 1,ks+ks-1
        jmin=max( 1, 1 + ks-jp)
        jmax=min(ns,ns + ks-jp)
        do j = jmin,jmax
          jj = j+jp-ks
          do ip = 1,ks+ks-1
            imin=max( 1, 1 + ks-ip)
            imax=min(ns,ns + ks-ip)
            do i = imin,imax
            ii = i+ip-ks
            a( i,jj) = a( i,jj) + rkb(i,j,ip,jp)*d(ii, j)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'n'.and.sym_j.eq.'n'.and.icase.eq.4) then
      do jp = 1,ks+ks-1
        jmin=max( 1, 1 + ks-jp)
        jmax=min(ns,ns + ks-jp)
        do j = jmin,jmax
          jj = j+jp-ks
          do ip = 1,ks+ks-1
            imin=max( 1, 1 + ks-ip)
            imax=min(ns,ns + ks-ip)
            do i = imin,imax
            ii = i+ip-ks
            a(ii, j) = a(ii, j) + rkb(i,j,ip,jp)*d( i,jj)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'n'.and.sym_j.eq.'s'.and.icase.eq.3) then
      do jp = 1,ks
        do j = 1,ns-jp+1
          jj = j+jp-1
          do ip = 1,ks+ks-1
            imin=max( 1, 1 + ks-ip)
            imax=min(ns,ns + ks-ip)
            do i = imin,imax
              ii = i+ip-ks
                     a( i,jj) = a( i,jj) + rkb(i,j,ip,jp)*d(ii, j)
         if(jp.gt.1) a( i, j) = a( i, j) + rkb(i,j,ip,jp)*d(ii,jj)
            end do
          end do
        end do
      end do
      elseif(sym_i.eq.'n'.and.sym_j.eq.'s'.and.icase.eq.4) then
      do jp = 1,ks
        do j = 1,ns-jp+1
          jj = j+jp-1
          do ip = 1,ks+ks-1
            imin=max( 1, 1 + ks-ip)
            imax=min(ns,ns + ks-ip)
            do i = imin,imax
              ii = i+ip-ks
                     a(ii, j) = a(ii, j) + rkb(i,j,ip,jp)*d( i,jj)
         if(jp.gt.1) a(ii,jj) = a(ii,jj) + rkb(i,j,ip,jp)*d( i, j)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'s'.and.sym_j.eq.'n'.and.icase.eq.3) then
      do jp = 1,ks+ks-1
        jmin=max( 1, 1 + ks-jp)
        jmax=min(ns,ns + ks-jp)
        do j = jmin,jmax
          jj = j+jp-ks
          do ip = 1,ks
            do i = 1,ns-ip+1
              ii = i+ip-1
                     a( i,jj) = a( i,jj) + rkb(i,j,ip,jp)*d(ii, j)   ! ????
       if(ip.gt.1)   a(ii,jj) = a(ii,jj) + rkb(i,j,ip,jp)*d( i, j)
            end do
          end do
        end do
      end do
    elseif(sym_i.eq.'s'.and.sym_j.eq.'n'.and.icase.eq.4) then
      do jp = 1,ks+ks-1
        jmin=max( 1, 1 + ks-jp)
        jmax=min(ns,ns + ks-jp)
        do j = jmin,jmax
          jj = j+jp-ks
          do ip = 1,ks
            do i = 1,ns-ip+1
              ii = i+ip-1
                     a(ii, j) = a(ii, j) + rkb(i,j,ip,jp)*d( i,jj)   ! ????
       if(ip.gt.1)   a( i, j) = a( i, j) + rkb(i,j,ip,jp)*d(ii,jj)
            end do
          end do
        end do
      end do
      else
        Stop ' CONVOL:  unknown case '
      end if
      END SUBROUTINE convol


!=======================================================================
    SUBROUTINE coulom(z, l, a, b)
!=======================================================================
!
!   Builds full a and b matrices for the coulomb problem
!
!   a(i,j) = integration of B_i*(DD+2*z/r-l(l+1)/r**2)*B_j
!   b(i,j) = integration of B_i*B_j
!
!   from the banded symmetric form of these elementary operators
!
!-----------------------------------------------------------------------
!
!   on exit
!   -------
!       a      full matrix for coulomb operator not assumed
!              to be symmetric
!       b      full matrix of the overlap operator
!-------------------------------------------------------------------
    USE spline_param
    USE spline_galerkin
    USE spline_hl
    IMPLICIT NONE
    REAL(KIND=8), INTENT(in) :: z
    INTEGER, INTENT(in) :: l
    REAL(KIND=8), DIMENSION(ns,ns), INTENT(OUT) :: a, b
    ! ..  LOCAL variables
    INTEGER :: i,j
    ! .. initialize
    a = 0.d0
    b = 0.d0
    Call HLM(l)
    ! .. lower matrix
    do j = 1,ks
      do i = ks-j+1,ns
        a(i,i-ks+j) = hl(i,j)
        b(i,i-ks+j) = sb(i,j)
      end do
    end do
    ! .. upper matrix by symmetry
    do j = ks+1,2*ks-1
      do i = j+1-ks,ns
        a(i-j+ks,i) = hl(i,2*ks-j)
        b(i-j+ks,i) = sb(i,2*ks-j)
      end do
    end do
    ! .. correction for asymmetry in db2
    a(ns-1,ns) = hl(1,1)
  END SUBROUTINE coulom


!=========================================================================
      SUBROUTINE define_grid(z)
!=========================================================================
!
!     gets input data for the grid and sets up the spline knots
!
!     Requires file  'knot.dat' with grid parameters
!
! -------------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      Real(8) :: z
      Logical :: EX
! ... get input data for the grid
      Inquire(file=AF_grid,exist=EX)
      if(.not.EX) Stop 'provide knot.dat file for splines parameters !'
      Open(nug,file=AF_grid); Rewind(nug)
      Call Read_ipar(nug,'grid_type',grid_type)
      Select case(grid_type)
       Case(0);  Call define_grid_00(z)
       Case(1);  Call define_grid_01(z)
       Case default; Stop ' Unknown grid_type '
      End Select
      Close(nug)
      END SUBROUTINE define_grid
!=========================================================================
      SUBROUTINE define_grid_00(z)
!=========================================================================
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      Real(8) :: z
      rewind(nug)
      read(nug,*) ks
      read(nug,*) ns
      read(nug,*) z
      read(nug,*) h
      read(nug,*) hmax
      read(nug,*) rmax
! ... set up the knots for spline
      CALL mkgrid(z)
! ... print grid in the file 'knot.dat'
      rewind(nug)
      write(nug,'(i12,a)') ks,' ==>  order  of splines (ks)'
      write(nug,'(i12,a)') ns,' ==>  number of splines (ns)'
      write(nug,'(f12.5,a)') z,' ==>  nuclear charge (z)'
      write(nug,'(f12.5,a)') h,' ==>  step size from 0 to 1 (h for z*r, = (1/2)^n)'
      write(nug,'(f12.5,a)') hmax,' ==>  maximum step size (hmax for r)'
      write(nug,'(f12.5,a)') rmax,' ==>  maximum r (rmax)'
      write(nug,'(a)') '***'
      write(nug,'(5f12.5)') t(1:ns+ks)
      write(nug,'(a)') '***'
      write(nug,'(i12,a)') ml,' ==>  number of distinct knots from 0 to 1 (=1/h)'
      write(nug,'(i12,a)') me,' ==>  number of knots in the exponential region '
      write(nug,'(i12,a)') nv,' ==>  number of intervals '
      write(nug,'(f12.5,a)') (1/hmax)**2,' ==>  max k^2 (Ry) '
      END SUBROUTINE define_grid_00
!=====================================================================
    SUBROUTINE mkgrid(z)
!=====================================================================
!
!   sets up the knots for spline (original version)
!
!---------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      INTEGER(4) :: n, i, m, me1, me2, nt
      REAL(8):: z,hp1, h2, tmax, tx, h0
      ! .. determine ml, the number of distinct points from 0 to 1
       h0 = h
       ml = 1.d0/h + 0.1
       h = 1.d0/ml
       hp1 = 1.d0 + h
      ! .. determine tmax
      tmax = z*rmax
      hmax = z*hmax
      ! .. determine final point of "exponential" grid
      ! .. me: number of points from 1 to (1+h)**me
      ! .. m:  number of points from (1+h)**me to tmax
      me1 = MAX(0.0d0, LOG(hmax/h)/LOG(hp1)+1.d0)
      me2 = LOG(tmax)/LOG(hp1)+1
      IF ( me2 <= me1 ) THEN
        me = me2
        m = 0
      ELSE
        me = me1
        tx = hp1**me
        h2 = h*tx/hp1
        m = NINT((tmax-tx)/h2)
      END IF
      n = ml + me + m + ks -1
      ns = n
      nv = ns - (ks -1)
      nt = ns + ks
      ! .. establish the grid for z*r
      ALLOCATE (t(nt)); t = 0.d0
      DO i = ks+1, ks+ml
        t(i) = t(i-1) + h0
      END DO
      DO i = ks+ml+1, ks+me+ml
        t(i) = t(i-1)*hp1
      END DO
      DO i = ks+me+ml+1, n+1
        t(i) = t(i-1) + h2
      END DO
      t(n+2:nt) = t(n+1)
      ! .. scale the values to the R variable
      t = t/z
      hmax = hmax/z
    END SUBROUTINE mkgrid
!=========================================================================
      SUBROUTINE define_grid_01(z)
!=========================================================================
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      Real(8) :: z
      Call Read_ipar(nug,'ks',ks)
      Call Read_ipar(nug,'ns',ns)
      Call Read_rpar(nug,'z' ,z)
      Call Read_rpar(nug,'h' ,h)
      Call Read_rpar(nug,'hmax',hmax)
      Call Read_rpar(nug,'rmax',rmax)
! ... set up the knots for spline
      CALL mkgrid1(z)
! ... print grid in the file 'knot.dat'
      rewind(nug)
      write(nug,'(a,i2,a)') 'grid_type = ',grid_type,' !  type of grid '
      write(nug,*)
      write(nug,'(a,i3,a)') 'ks = ',ks,' ! order of splines '
      write(nug,'(a,i3,a)') 'ns = ',ns,' ! number of splines '
      write(nug,'(a,f10.5,a)') 'z = ',z,' ! nuclear charge'
      write(nug,'(a,f10.5,a)') 'h = ',h,' ! step size from 0 to 1, for z*r'
      write(nug,'(a,f10.5,a)') 'hmax = ',hmax,' ! maximum step size for r '
      write(nug,'(a,f10.5,a)') 'rmax = ',rmax,' ! maximum r '
      write(nug,'(a)') '***'
      write(nug,'(5f12.5)') t(1:ns+ks)
      write(nug,'(a)') '***'
      write(nug,'(i12,a)') ml,' ==>  number of distinct knots from 0 to 1 (=1/h)'
      write(nug,'(i12,a)') me,' ==>  number of knots in the exponential region '
      write(nug,'(i12,a)') nv,' ==>  number of intervals '
      write(nug,'(f12.5,a)') (1/hmax)**2,' ==>  max k^2 (Ry) '
      END SUBROUTINE define_grid_01
!=====================================================================
      SUBROUTINE mkgrid1(z)
!=====================================================================
!
!     sets up the knots for splines in semi-exponential grid:
!
!-----------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      INTEGER(4):: i,nt
      Real(8) :: z
      rmax = rmax * z
      hmax = hmax * z
      nt = rmax / h + 1 + ks
      if(Allocated(t)) Deallocate(t)
      ALLOCATE (t(nt))
      t = 0.d0
      ns = ks
	
! ... determine ml, the number of intervals from 0 to 1
! ... first make sure that h = 1/n as recomended
      ml = 1.d0/h + 0.5;  h = 1.d0/ml
      Do i=1,ml
       ns = ns + 1; t(ns) = t(ns-1) + h
      End do
! ... determine me, the number of intervals in "exponential" grid
      if(hmax.lt.h) hmax = h
      me = 0
      Do
       t(ns+1) = t(ns)*(1.d0+h)
       if(t(ns+1)-t(ns).gt.hmax) Exit
       ns = ns + 1
       if(t(ns).gt.rmax) Exit
       me = me + 1
      End do
! ... rest of interval with step = hmax
      if(t(ns).lt.rmax) then
       Do
        t(ns+1) = t(ns) + hmax
        ns = ns + 1
        if(t(ns).ge.rmax) Exit
       End do
      end if
      if(t(ns).gt.rmax) then
       ns = ns - 1; me = me - 1
       t(ns+1:ns+ks) = rmax
       t(ns) = (t(ns+1)+t(ns-1))/2.d0
      end if
      nv = ns - ks + 1
! ... scale to the R variable
      t = t/z
      hmax = hmax / z
      rmax = rmax / z
      END SUBROUTINE mkgrid1


!======================================================================
    SUBROUTINE define_spline
!======================================================================
!
!   initializes the values of the spline and its derivatives
!   and evaluates the spline basic arrays (elementary operators in
!   spline basis).
!
!   SUBROUTINE called:
!       gauss
!       allocate_grid
!       initvb
!       allocate_galerkin
!       initas
!
!   calling sequence:
!                        define_spline
!                   ----------------------
!                  / |          ||      ||
!                 /  |        initvb   initas
!                /   |           |     // \  \\
!           gauss    |        vbsplvd mdb mrm facsb
!                    |           ||
!       allocate_grid,galerkin vbsplvb
!
!----------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    IMPLICIT NONE
    REAL(8), DIMENSION(ks) :: gx, gw
    ! .. initializes variables for gaussian integration
    CALL gauss(ks,gx,gw)
    ! .. initializes the values of the spline and its derivatives
    CALL allocate_grid
    CALL initvb
    ! .. initializes the spline array (operators in spline basis)
    Call allocate_galerkin
    CALL initas
    CONTAINS
!=======================================================================
    SUBROUTINE initvb
!=======================================================================
!
!   Sets (or Initializes) the arrays
!       gr      The gaussian points for the nint intervals of [0,Rmax]
!       grm     Reciprocals of the values of gr
!               (to avoid repeated division on the CRAY)
!       grw     Gaussian weights for each of the points in gr
!       bsp     array of B-spline values at the gaussian points
!       bspd    array of values of the first and second derivative of
!               the B-splines at the gaussian points
!
!   Calling sequence:
!        initvb
!          |
!       vbsplvd
!         ||
!       vbsplvb
!
!-----------------------------------------------------------------------
!   on entry
!   --------
!       gx      the gaussian points for the interval [0,1]
!       gw      the gaussian weights for the interval [0,1]
!
!   working arrays
!   --------------
!       dbiatx  working array of dimension (ns,ks,ks) which contains the
!               values and the second derivative values of of B-spline at
!               gaussian points in the interval [0,1]
!
!-----------------------------------------------------------------------
    IMPLICIT NONE
    REAL(8), Allocatable, DIMENSION(:,:,:) :: dbiatx
    INTEGER :: m, i
    Allocate(dbiatx(nv,ks,ks)); dbiatx = 0.d0
    Do m=1,ks
      gr(1:nv,m)=(t(1+ks:nv+ks)-t(ks:nv+ks-1))*gx(m)+t(ks:nv+ks-1)
      grm(1:nv,m) = 1.d0/gr(1:nv,m)
      grw(1:nv,m)=(t(1+ks:nv+ks)-t(ks:nv+ks-1))*gw(m)
      Call vbsplvd(t,ks,nv,gr(1,m),3,dbiatx)
      bsp(1:nv,m,1:ks)    = dbiatx(1:nv,1:ks,1)
      bspd(1:nv,m,1:ks,1) = dbiatx(1:nv,1:ks,2)
      bspd(1:nv,m,1:ks,2) = dbiatx(1:nv,1:ks,3)
      Do i = 1,ks
       bsq(1:nv,m,i) = bspd(1:nv,m,i,1) - grm(1:nv,m)*bsp(1:nv,m,i)
      End do
    End do
    ! .. store also the values at the last knot
    call vbsplvd(t,ns,1,t(ns+1),3,dbiatx)
    bsp(nv+1,1,1:ks)    = dbiatx(1,1:ks,1)
    bspd(nv+1,1,1:ks,1) = dbiatx(1,1:ks,2)
    bspd(nv+1,1,1:ks,2) = dbiatx(1,1:ks,3)
    bsq(nv+1,1,1:ks)    = bspd(nv+1,1,1:ks,1)-bsp(nv+1,1,1:ks)/t(ns+1)
    Deallocate(dbiatx)
    END SUBROUTINE initvb
!==================================================================
    SUBROUTINE initas
!==================================================================
!
!   Sets ( or Initializes ) the array in symmetric storage mode:
!
!       db1 --- matrix of integral <B_i,B'_j>
!       db2 --- matrix of integral <B_i,B"_j>
!       sb  --- matrix of integral <B_i,B_j>
!       r1  --- matrix of integral <B_i,r B_j>
!       rm1 --- matrix of integral <B_i,(1/r)B_j>
!       rm2 --- matrix of integral <B_i,(1/r^2)B_j>
!       rm3 --- matrix of integral <B_i,(1/r^3)B_j>
!               where i=1,..,ns, j=1,...ks
!
!   Calling sequence:
!       initas
!        /  \
!      mdb  mrm
!
!------------------------------------------------------------------
    IMPLICIT NONE
    CALL mdb1      ! .. sets db1 --- matrix of integral <B_i,B'_j>
    CALL mdb2      ! .. sets db2 --- matrix of integral <B_i,B"_j>
    CALL mrm(0, sb)              ! .. sets sb  ---  <B_i,B_j>
    CALL facsb                   ! .. factorizes sb
    CALL mrm(1, r1)              ! .. sets r1  ---  <B_i,r B_j>
    CALL mrm(-1, rm1)            ! .. sets rm1 ---  <B_i,(1/r)B_j>
    CALL mrm(-2, rm2)            ! .. sets rm2 ---  <B_i,(1/r^2)B_j>
    CALL mrm(-3, rm3)            ! .. sets rm2 ---  <B_i,(1/r^3)B_j>
   END SUBROUTINE initas
!====================================================================
   SUBROUTINE mdb1
!====================================================================
!
!  Computes the matrix elements <B_i,B'_i+j-1> in the B-spline basis
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    ! Local variables
    INTEGER :: i, irow, jcol, ith, jth
    db1 = 0.d0
    do ith = 1,ks
      do jth = 1,ith
        jcol = jth-ith+ks
        do i = 1,nv
          irow = i+ith-1
          db1(irow,jcol) = db1(irow,jcol) &
        + SUM(grw(i,:)*bsp(i,:,ith)*bspd(i,:,jth,1))
        end do
      end do
    end do
  END SUBROUTINE mdb1
!====================================================================
   SUBROUTINE mdb2
!====================================================================
!
!  Computes the matrix elements <B_i,B"_i+j-1> in the B-spline basis
!
!--------------------------------------------------------------------
    IMPLICIT NONE
    ! Local variables
    INTEGER :: i, irow, jcol, ith, jth
    db2 = 0.d0
    do ith = 1,ks
      do jth = 1,ith
        jcol = jth-ith+ks
        do i = 1,nv
          irow = i+ith-1
          db2(irow,jcol) = db2(irow,jcol) &
        + SUM(grw(i,:)*bsp(i,:,ith)*bspd(i,:,jth,2))
        end do
      end do
    end do
    db2(1,1) = db2(1,1) + SUM(grw(nv,:)*bsp(nv,:,ks-1)*bspd(nv,:,ks,2))
  END SUBROUTINE mdb2
  END SUBROUTINE define_spline


!======================================================================
      Subroutine density(ns,ks,d,p1,p2,type)
!======================================================================
!
!     d - density of two w.f. p1,p2
!     type = 's' - simmetrical direct case
!            'n' - nonsimmetrical direct
!            'x' - exchange case
!----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER, INTENT(in) :: ns,ks
      REAL(KIND=8), DIMENSION(ns) :: p1,p2
      REAL(KIND=8), DIMENSION(ns,*) :: d
      CHARACTER(LEN=1) :: type
      INTEGER :: i,j,imin,imax
      if(type.eq.'s') then                    !     o***
        d(1:ns,1:ks) = 0.d0
                                              !     o***
        do i =1,ns                            !     o***
          d(i,1) =  p1(i)*p2(i)               !     o***
        end do                                !     o**
                                              !     o*
        do j = 2,ks                           !     o
          do i = 1,ns-j+1
           d(i,j) =  p1(i)*p2(i+j-1) + p1(i+j-1)*p2(i)
          end do
        end do
      elseif(type.eq.'n') then                !     o***
                                              !    *o***
        d(1:ns,1:ks+ks-1) = 0.d0
        do j = 1,ks+ks-1                      !   **o***
          imin=max0( 1, 1+ks-j)               !  ***o***
          imax=min0(ns,ns+ks-j)               !  ***o**
          do i = imin,imax                    !  ***o*
            d(i,j) = p1(i)*p2(i+j-ks)         !  ***o
          end do
        end do
      else
        d(1:ns,1:ns) = 0.d0
        do i = 1,ns
          do j = 1,ns
            d(i,j) =  p1(i)*p2(j)
          end do
        end do
      end if
      END SUBROUTINE density


!======================================================================
      Subroutine DINTY (icase,ygr,ym)
!======================================================================
!
!    Computes the array elements   <B_i,  y(r) B _j>, if icase=0,
!                                  <B_i,  y(r) B'_j>, if icase=1,
!
!    in non-symmetric column storage mode
!
!    on entry
!    --------
!    ygr   array of values of a specific function  y(r) at the
!          gaussian points of each interval, weighted by the gaussian
!          weights
!
!    on exit
!    -------
!    ym    <B_i, y(r) B_j>  or  <B_i, y(r) B'_j>
!          in non-symmetric column storage mode
!--------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    IMPLICIT NONE
    INTEGER, INTENT(in) :: icase
    REAL(KIND=8), DIMENSION(nv,ks), INTENT(in) :: ygr
    REAL(KIND=8), DIMENSION(ns,2*ks-1), INTENT(out) :: ym
    ! .. local variables
    INTEGER :: ith, jth, i, irow, jcol
    ym = 0.d0                   ! clear ym array
    do i = 1,nv                 ! over intervals
      do ith = 1,ks             ! over left B-splines
        irow = i+ith-1
        do jth = 1,ks           ! over right B-splines
          jcol = jth-ith+ks
          if(icase.eq.0)  ym(irow,jcol) = ym(irow,jcol) + &
                SUM(ygr(i,:)*bsp(i,:,ith)*bsp (i,:,jth))
          if(icase.eq.1)  ym(irow,jcol) = ym(irow,jcol) + &
                SUM(ygr(i,:)*bsp(i,:,ith)*bspd(i,:,jth,1))
        end do
      end do
    end do
    End Subroutine DINTY


!=======================================================================
    SUBROUTINE dxv(k,n,b,v,y)
!=======================================================================
!
!   Computes   y = b * v    where b is a anti-symmetric, banded matrix,
!   in lower-band storage mode,  and v, y are vectors.
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       k       the number of diagonals
!       n       the order of the matrix
!       b       the symmetric, banded matrix in column storage mode
!       v       vector
!
!   on exit
!   -------
!       y       y = b*v
!
!-----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n, k
    REAL(KIND=8), DIMENSION(n), INTENT(IN) ::v
    REAL(KIND=8), DIMENSION(n,k), INTENT(IN) ::b
    REAL(KIND=8), DIMENSION(n), INTENT(out) :: y
! ... Local variables
    INTEGER :: i, j, jp
! ...   off diagonal elements only
        Do jp = 1,k-1;   Do i = k-jp+1,n;  j = i-k+jp
          y(i) = y(i) + b(i,jp)*v(j)             ! sub_diagonals
          y(j) = y(j) - b(i,jp)*v(i)             ! super-diagonals
        End do;  End do
     END SUBROUTINE dxv


!====================================================================
    SUBROUTINE facdyk(ktx,k,ipvtd,dyk)
!====================================================================
!
!   Sets up the matrix
!
!       DD(i,j)-k*(k+1)*rm2
!
!   for solving the following differential equation by the
!   spline-Galerkin method:
!
!       (d^2-k(k+1)/r^2)yk(r) = -(2k+1) B_jf B_js(r)/r,
!
!   with boundary conditions:
!       at r=0, yk(r) = 0;
!       at r=rmax, yk(r) = const, if k=0,
!                  dy/dr + (k/r)y = B_jf(r) B_js(r) if k>0.
!
!   CALL:    dgbfa (LINPACK)  or DGBTRF (LAPACK)
!
!--------------------------------------------------------------------
!
!   on entry
!   --------
!       ktx  the leading dimension of dyk
!       k    the order of y.
!
!   on exit
!   -------
!       dyk  factorized array for the differential with operator
!            (d^2-k(k+1)/r^2). dyk is banded with
!            width 3*ks-2. The first ks-1 rows are zeros, and the
!            following k rows are the elements above the diagnal,
!            the last ks-1 rows are the elements below the diagnal of
!            the original arrays.
!
!--------------------------------------------------------------------
    USE spline_param; USE spline_grid; USE spline_galerkin
    IMPLICIT NONE
    INTEGER(4), INTENT(IN) :: ktx, k
    REAL(8), DIMENSION(ktx,ns) :: dyk
    INTEGER(4), DIMENSION(ns) :: ipvtd
    REAL(8) :: fkk
    INTEGER(4) :: i, j, nn, ier
    fkk = -k*(k+1)
    dyk=0.d0              ! .. clear the dyk array
    ! .. set up dyk
    ! .. lower portion
    do j=1,ks
      do i=ks-j+1,ns
        dyk(3*ks-1-j,i-ks+j)=db2(i,j)+fkk*rm2(i,j)
      end do
    end do
    ! .. upper portion
    do j=2,ks
      do i=1,ns-j+1
        dyk(2*ks-j,i+j-1)=db2(i+j-1,ks-j+1)+fkk*rm2(i+j-1,ks-j+1)
      end do
    end do
    ! .. correct the upper portion of the matrix for the asymmetry
    ! .. of d^2/dr^2
    j = 2*ks-2
    dyk(j,ns) = dyk(j,ns) + db2(1,1) - db2(ns,ks-1)
    ! .. apply the zero boundary condition at the origin and modify the
    ! .. last equation for the boundary condition at rmax
    do i=1,ks
      j=2*ks-i
      dyk(j,i)=0.d0
      j=3*ks-1-i
      dyk(j,ns-ks+i)=0.d0
    end do
    dyk(2*ks-1,1)=1.d0
    ! .. apply the boundary condition at rmax
    ! .. yk(r) = const, if k=0,
    ! .. dy/dr + (k/r)y = B_jf(r) B_js(r) if k>0.
    if (k /= 0) then
      nn = nv+1
      dyk(2*ks,ns-1)=bspd(nn,1,ks-1,1)
      dyk(2*ks-1,ns)=bspd(nn,1,ks,  1) + bsp(nn,1,ks)*k/t(ns+1)
    else
      dyk(2*ks-1,ns) = 1.d0
    end if
    ! .. factorize dyk
!    CALL dgbfa(dyk,ktx,ns,ks-1,ks-1,ipvtd,ier)
!    IF (ier /= 0) STOP 'FACDYK: dgbtrf from LINPACK failed'
     Call DGBTRF (ns,ns,ks-1,ks-1,dyk,ktx,ipvtd,ier)
     if (ier .ne. 0) Stop 'FACDYK: dgbtrf from LAPACK failed'
  END SUBROUTINE facdyk


!======================================================================
      Subroutine FACDZK (ktx,k,dzk,ipvtz)
!======================================================================
!
!     Sets up and factorizes the matrix
!
!         D(i,j) + k/r
!
!     for solving the following differential equation by the
!     spline-Galerkin method:
!
!         (d + k/r) zk(r) = f(r)
!
!     Calls:  dgbtrf (LAPACK) or  dgbfa (LINPACK)
!
!     on entry
!     --------
!     k      define equation
!
!     on exit
!     -------
!     dzk  factorized array for the differential with operator
!          (d+k/r).  dzk is banded with width 3*ks-2.
!          The first ks-1 rows are zeros, and the
!          following k rows are the elements above the diagnal,
!          the last ks-1 rows are the elements below the diagonal of
!          the original arrays.
!     iptvz  an integer vector of pivot indices.
!--------------------------------------------------------------------
    USE spline_param
    USE spline_galerkin
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ktx,k
    REAL(KIND=8), DIMENSION(ktx,ns), INTENT(OUT) :: dzk
    INTEGER, DIMENSION(ns), INTENT(OUT) :: ipvtz
    ! ..  local variables
    INTEGER :: i, j, ier
! .. clear the first empty rows of dzk array  ...
     do i=1,ks-1
      do j=1,ns
        dzk(i,j)=0.d0
      end do
     end do
! .. lower portion ...  (last rows of dyk)
     do j=1,ks
       do i=ks-j+1,ns
         dzk(3*ks-1-j,i-ks+j) = db1(i,j) + k*rm1(i,j)
       end do
     end do
! .. upper portion ...
     do j=2,ks
       do i=1,ns-j+1
         dzk(2*ks-j,i+j-1) = - db1(i+j-1,ks-j+1) + k*rm1(i+j-1,ks-j+1)
       end do
     end do
! .. preparation for boundary conditions
      do i=1,ks
       j=2*ks-i
       dzk(j,i)=0.d0                  ! first equation
      end do                          ! for zero value in origin
      dzk(2*ks-1,1)=1.d0
      if(k.eq.-1) then
       do i=1,ks
        dzk(2*ks+1-i,i)=0.d0          ! second equation (for Nk integrals)
       end do                         ! for zero derivative in origin
       dzk(2*ks-1,2)=1.d0
      end if
      if(k.le.-3) then
       do i=1,ks
        dzk(3*ks-1-i,ns-ks+i)=0.d0    ! last equation (for Vk integrals)
       end do                         ! for boudary condition at the end
       dzk(2*ks-1,ns) = 1.d0
      end if
! .. factorize dzk ...
!      CALL dgbfa(dzk,ktx,ns,ks-1,ks-1,ipvtz,ier)
!      IF (ier /= 0) STOP 'FACDZK: dgbfa (LINPACK) failed'
      Call DGBTRF (ns,ns,ks-1,ks-1,dzk,3*ks-2,ipvtz,ier)
      if (ier .ne. 0) stop 'FACDZK: dgbtrf (LAPACK) failed'
    End Subroutine FACDZK


!====================================================================
    SUBROUTINE facsb
!====================================================================
!
!   Factorizes bs matrix which is a transpose of overlap matrix sb,
!   <B_i,B_j>,  with the correct boundary condition at r=0
!
!   SUBROUTINES called:  dpbfa (from LINPACK)
!
!--------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    IMPLICIT NONE
    INTEGER :: m, ierr
    ! .. copy the array, converting to row oriented band storage mode
    bs = TRANSPOSE(sb)
    ! .. apply boundary condition at r=0
    do m = 1,ks-1
      bs(m,ks-m+1)=0.d0
    end do
    bs(ks,1) = 1.d0
!    CALL dpbfa(bs,ks,ns,ks-1,ierr)
!    if (ierr /= 0 ) STOP 'facsb: dpbfa (LINPACK) failed'
    Call DPBTRF('U',ns,ks-1,bs,ks,ierr)
    if (ierr.ne.0)  Stop 'facsb: dpbtrf (LAPACK) failed'
  END SUBROUTINE facsb


!====================================================================
      SUBROUTINE facsbl(l)
!====================================================================
!
!     Sets up the overlap bs which is a transpose of sb, <B_i,B_j>,
!     with the correct boundary conditions, and then factorizes bs.
!
!     SUBROUTINES called:   DPBTRF (from LAPACK)
!
!--------------------------------------------------------------------
      USE spline_param; USE spline_galerkin
      IMPLICIT NONE
      INTEGER(4), intent(in) :: l
      INTEGER(4) :: i,j, ierr
      bs = TRANSPOSE(sb)
! ... apply zero boundary condition at r=0:
      Do i = 1,l+1
       bs(ks,i) = 1.d0
       Do j = 1,ks-1
        bs(j,ks-j+i) = 0.d0
       End do
      End do
! ... apply zero boundary condition at r=a:
      Do i = 1,ks-1
       bs(i,ns)=0.d0
       bs(i,ns-1)=0.d0
      End do
      bs(ks,ns  ) = 1.d0
      bs(ks,ns-1) = 1.d0
      Call DPBTRF('U',ns,ks-1,bs,ks,ierr)
      if (ierr .ne. 0 )  Stop 'facsbl: dpbtrf (LAPACK) failed'
      END SUBROUTINE facsbl


!=======================================================================
    SUBROUTINE gauss(k,x,w)
!=======================================================================
!   Looks up the values of gaussian coordinates and guassian weights
!   for k-point gaussian quadrature over the interval [0, 1].
!
!   on entry:  k     the number of points in the quadrature
!   -------
!
!   on exit:  x(i)   Gaussian coordinates of the points
!   -------   w(i)   Gaussian weight to point x(i)
!
!   Restriction:  1<= k <= 15   FOR k POINT CASE
!   -----------
!
!-----------------------------------------------------------------------
!
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    REAL(KIND=8), DIMENSION(k), INTENT(OUT) :: x, w
    IF (k < 1 .OR. k > 15)   &
       Stop 'Error in GAUSS: number of points is out of range '
    SELECT CASE ( k )
    CASE (1)
      x(1) = .5d0
      w(1) = 1.d0
    CASE (2)
      x(1) = .211324865405187d0
      x(2) = .788675134594813d0
      w(1) = .5d0
      w(2) = .5d0
    CASE (3)
      x(1) = .112701665379258d0
      x(2) = .5d0
      x(3) = .887298334620742d0
      w(1) = .277777777777778d0
      w(2) = .444444444444444d0
      w(3) = .277777777777778d0
    CASE (4)
      x(1) = .0694318442029737d0
      x(2) = .330009478207572d0
      x(3) = .669990521792428d0
      x(4) = .930568155797026d0
      w(1) = .173927422568727d0
      w(2) = .326072577431273d0
      w(3) = .326072577431273d0
      w(4) = .173927422568727d0
    CASE (5)
      x(1) = .046910077030668d0
      x(2) = .230765344947158d0
      x(3) = .5d0
      x(4) = .769234655052842d0
      x(5) = .953089922969332d0
      w(1) = .118463442528095d0
      w(2) = .239314335249683d0
      w(3) = .284444444444444d0
      w(4) = .239314335249683d0
      w(5) = .118463442528095d0
    CASE (6)
      x(1) = .033765242898424d0
      x(2) = .169395306766868d0
      x(3) = .380690406958402d0
      x(4) = .619309593041598d0
      x(5) = .830604693233132d0
      x(6) = .966234757101576d0
      w(1) = .0856622461895852d0
      w(2) = .180380786524069d0
      w(3) = .233956967286346d0
      w(4) = .233956967286346d0
      w(5) = .180380786524069d0
      w(6) = .0856622461895852d0
    CASE (7)
      x(1) = .0254460438286207d0
      x(2) = .129234407200303d0
      x(3) = .297077424311301d0
      x(4) = .5d0
      x(5) = .702922575688699d0
      x(6) = .870765592799697d0
      x(7) = .974553956171379d0
      w(1) = .0647424830844348d0
      w(2) = .139852695744638d0
      w(3) = .19091502525256d0
      w(4) = .208979591836735d0
      w(5) = .19091502525256d0
      w(6) = .139852695744638d0
      w(7) = .0647424830844348d0
    CASE (8)
      x(1) = .0198550717512319d0
      x(2) = .101666761293187d0
      x(3) = .237233795041835d0
      x(4) = .408282678752175d0
      x(5) = .591717321247825d0
      x(6) = .762766204958164d0
      x(7) = .898333238706813d0
      x(8) = .980144928248768d0
      w(1) = .0506142681451881d0
      w(2) = .111190517226687d0
      w(3) = .156853322938944d0
      w(4) = .181341891689181d0
      w(5) = .181341891689181d0
      w(6) = .156853322938944d0
      w(7) = .111190517226687d0
      w(8) = .0506142681451881d0
    CASE (9)
      x(1) = .015919880246187d0
      x(2) = .0819844463366821d0
      x(3) = .193314283649705d0
      x(4) = .337873288298095d0
      x(5) = .5d0
      x(6) = .662126711701904d0
      x(7) = .806685716350295d0
      x(8) = .918015553663318d0
      x(9) = .984080119753813d0
      w(1) = .0406371941807872d0
      w(2) = .0903240803474287d0
      w(3) = .130305348201468d0
      w(4) = .156173538520001d0
      w(5) = .16511967750063d0
      w(6) = .156173538520001d0
      w(7) = .130305348201468d0
      w(8) = .0903240803474287d0
      w(9) = .0406371941807872d0
    CASE (10)
      x(1) = .0130467357414141d0
      x(2) = .0674683166555077d0
      x(3) = .160295215850488d0
      x(4) = .283302302935376d0
      x(5) = .425562830509184d0
      x(6) = .574437169490816d0
      x(7) = .716697697064624d0
      x(8) = .839704784149512d0
      x(9) = .932531683344492d0
      x(10)= .986953264258586d0
      w(1) = .0333356721543441d0
      w(2) = .0747256745752903d0
      w(3) = .109543181257991d0
      w(4) = .134633359654998d0
      w(5) = .147762112357376d0
      w(6) = .147762112357376d0
      w(7) = .134633359654998d0
      w(8) = .109543181257991d0
      w(9) = .0747256745752903d0
      w(10)= .0333356721543441d0
    CASE (11)
      x(1) = .0108856709269715d0
      x(2) = .0564687001159523d0
      x(3) = .134923997212975d0
      x(4) = .240451935396594d0
      x(5) = .365228422023827d0
      x(6) = .5d0
      x(7) = .634771577976172d0
      x(8) = .759548064603406d0
      x(9) = .865076002787025d0
      x(10)= .943531299884048d0
      x(11)= .989114329073028d0
      w(1) = .0278342835580868d0
      w(2) = .0627901847324523d0
      w(3) = .0931451054638672d0
      w(4) = .116596882295995d0
      w(5) = .131402272255123d0
      w(6) = .13646254338895d0
      w(7) = .131402272255123d0
      w(8) = .116596882295995d0
      w(9) = .0931451054638672d0
      w(10)= .0627901847324523d0
      w(11)= .0278342835580868d0
    CASE (12)
      x(1) = .00921968287664038d0
      x(2) = .0479413718147626d0
      x(3) = .115048662902848d0
      x(4) = .206341022856691d0
      x(5) = .31608425050091d0
      x(6) = .437383295744266d0
      x(7) = .562616704255734d0
      x(8) = .68391574949909d0
      x(9) = .793658977143309d0
      x(10)= .884951337097152d0
      x(11)= .952058628185237d0
      x(12)= .99078031712336d0
      w(1) = .0235876681932559d0
      w(2) = .0534696629976592d0
      w(3) = .0800391642716731d0
      w(4) = .101583713361533d0
      w(5) = .116746268269177d0
      w(6) = .124573522906701d0
      w(7) = .124573522906701d0
      w(8) = .116746268269177d0
      w(9) = .101583713361533d0
      w(10)= .0800391642716731d0
      w(11)= .0534696629976592d0
      w(12)= .0235876681932559d0
    CASE (13)
      x(1) = .00790847264070593d0
      x(2) = .041200800388511d0
      x(3) = .099210954633345d0
      x(4) = .17882533027983d0
      x(5) = .275753624481777d0
      x(6) = .384770842022433d0
      x(7) = .5d0
      x(8) = .615229157977567d0
      x(9) = .724246375518223d0
      x(10)= .82117466972017d0
      x(11)= .900789045366655d0
      x(12)= .958799199611489d0
      x(13)= .992091527359294d0
      w(1) = .0202420023826579d0
      w(2) = .0460607499188642d0
      w(3) = .0694367551098937d0
      w(4) = .0890729903809729d0
      w(5) = .103908023768444d0
      w(6) = .113141590131449d0
      w(7) = .116275776615437d0
      w(8) = .113141590131449d0
      w(9) = .103908023768444d0
      w(10)= .0890729903809729d0
      w(11)= .0694367551098937d0
      w(12)= .0460607499188642d0
      w(13)= .0202420023826579d0
    CASE (14)
      x(1) = .00685809565159383d0
      x(2) = .0357825581682132d0
      x(3) = .0863993424651175d0
      x(4) = .156353547594157d0
      x(5) = .242375681820923d0
      x(6) = .340443815536055d0
      x(7) = .445972525646328d0
      x(8) = .554027474353672d0
      x(9) = .659556184463945d0
      x(10)= .757624318179077d0
      x(11)= .843646452405843d0
      x(12)= .913600657534882d0
      x(13)= .964217441831787d0
      x(14)= .993141904348406d0
      w(1) = .0175597301658759d0
      w(2) = .0400790435798801d0
      w(3) = .0607592853439516d0
      w(4) = .0786015835790968d0
      w(5) = .092769198738969d0
      w(6) = .102599231860648d0
      w(7) = .107631926731579d0
      w(8) = .107631926731579d0
      w(9) = .102599231860648d0
      w(10)= .092769198738969d0
      w(11)= .0786015835790968d0
      w(12)= .0607592853439516d0
      w(13)= .0400790435798801d0
      w(14)= .0175597301658759d0
    CASE (15)
      x(1) = .00600374098975728d0
      x(2) = .031363303799647d0
      x(3) = .0758967082947864d0
      x(4) = .137791134319915d0
      x(5) = .214513913695731d0
      x(6) = .302924326461218d0
      x(7) = .399402953001283d0
      x(8) = .5d0
      x(9) = .600597046998717d0
      x(10)= .697075673538782d0
      x(11)= .785486086304269d0
      x(12)= .862208865680085d0
      x(13)= .924103291705214d0
      x(14)= .968636696200353d0
      x(15)= .993996259010243d0
      w(1) = .0153766209980586d0
      w(2) = .0351830237440541d0
      w(3) = .053579610233586d0
      w(4) = .0697853389630772d0
      w(5) = .083134602908497d0
      w(6) = .0930805000077812d0
      w(7) = .0992157426635559d0
      w(8) = .101289120962781d0
      w(9) = .0992157426635559d0
      w(10)= .0930805000077812d0
      w(11)= .083134602908497d0
      w(12)= .0697853389630772d0
      w(13)= .053579610233586d0
      w(14)= .0351830237440541d0
      w(15)= .0153766209980586d0
   END SELECT
  END SUBROUTINE gauss


!=======================================================================
    Real(8) FUNCTION grad(i,j)
!=======================================================================
!
!   <p(i)| d + [l(j)(l(j)+1)-l(i)*(l(i)+1)]/2r |p(j)>
!
!-----------------------------------------------------------------------
    USE spline_param
    USE spline_galerkin
    USE spline_orbitals, L => LBS, mx => MBS, p => PBS
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i,j
    INTEGER :: ll,ii,jj,jp
      if(iabs(L(I)-L(J)).ne.1)  Stop ' BS_GRAD: L(i) - L(j) <> 1'
      ll = (L(j)*(L(j)+1)-L(i)*(L(i)+1))/2
      grad = ll * SUM(p(:,i)*p(:,j)*rm1(:,ks))
      do jp=1,ks-1;  do ii=ks+1-jp,ns;  jj=jp+ii-ks
         grad =  grad &
           +     db1(ii,jp) * (p(jj,j)*p(ii,i) - p(jj,i)*p(ii,j)) &
           +  ll*rm1(ii,jp) * (p(jj,j)*p(ii,i) + p(jj,i)*p(ii,j))
      end do;  end do
    END FUNCTION grad


!======================================================================
      DOUBLE PRECISION FUNCTION HLC(I,J)
!======================================================================
!
!     COMPUTES HL(I,J) MODIFIED BY THE INTERACTIONS WITH
!     THE CLOSED SHELL
!----------------------------------------------------------------------
      USE spline_orbitals, l => lbs
      USE spline_atomic, nclosd => kclosd
      IMPLICIT NONE
      INTEGER, INTENT(in) :: i,j
! ..  local variable
      INTEGER :: ip, k, kmin, kmax
      REAL(KIND=8), EXTERNAL :: ZCB, RKy, BHL
      REAL(KIND=8) :: CA, CB
      HLC = BHL(I,J)
      DO IP = 1,NCLOSD
         CA = -2.d0*(4*L(IP)+2)
         HLC = HLC + CA*RKY(I,IP,J,IP,0)
      END DO
      kmin = 1000
      kmax = 0
      DO IP = 1,NCLOSD
       k = iabs(L(I)-L(IP))
       if(k.lt.kmin) kmin = k
       k =      L(I)+L(IP)
       if(k.gt.kmax) kmax = k
      End do
      DO k = kmin,kmax
        DO IP = 1,NCLOSD
           CB =  ZCB(L(I),K,L(IP)) * (4*L(IP)+2)
           if(CB.eq.0.d0) Cycle
           HLC = HLC + CB*RKY(I,IP,IP,J,k)
        END DO
      END DO
    END function HLC


!====================================================================
    SUBROUTINE hlm(l)
!====================================================================
!
!   Sets up the matrix hl for the coulomb operator
!
!       hl(i,j) = DD(i,j) - l*(l+1)*rm2(i,j) + 2 * z*rm1(i,j)
!
!   in symmetric band storage mode, where i=1,ns, j=1,ks and
!   hl(1,1) stores <B_{ns-1},H B_{ns}>.
!
!--------------------------------------------------------------------
!   on entry
!   --------
!       z    nuclear charge
!       l    orbital angular momentum
!--------------------------------------------------------------------
    USE spline_param
    Use spline_atomic
    USE spline_grid
    Use spline_galerkin
    Use spline_hl
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: l
    REAL(KIND=8) :: fl, zz, a
    Real(8), External :: AZL
    if(lh.eq.-1) Call Allocate_hl
    if(lh.eq.l) Return
    fl = l*(l+1.d0)
    zz = 2.d0*z
!.. set up hl matrix
    hl = db2 - fl*rm2 + zz*rm1
!.. store the (ns-1,ns) asymmetric value in hl(1,1)
    hl(1,1) = hl(ns,ks-1) + (db2(1,1)-db2(ns,ks-1))
!.. relativistic shift
    if(rel) then
     Call mvc(l)
     hl = hl + fine*vc
     if(l.eq.0) then
      a = azl(z,h,ks,l+1)
      hl(2,ks) = hl(2,ks) - z*a*a*fine
     end if
    end if
    lh = l
  END SUBROUTINE hlm


!=======================================================================
      Subroutine INT_de (p1,p2,x,int,icase,sym_x)
!=======================================================================
!
!     Contribution to channel-channel interaction matrix from
!     the two-electron integrals:
!
!     icase = 1 -->  INT( . p1; . p2)
!     icase = 2 -->  INT( p1 .;p2 . )
!     icase = 3 -->  INT( . p1;p2 . )
!     icase = 4 -->  INT( p1 .; . p2)
!
!     result is in x array: x/ich,jch/
!-----------------------------------------------------------------------
      USE spline_param
      IMPLICIT NONE
      INTEGER, INTENT(in) :: int, icase
      REAL(KIND=8), INTENT(in), DIMENSION(ns) :: p1,p2
      REAL(KIND=8), INTENT(out), DIMENSION(ns,*) :: x
      Character(1), INTENT(out) :: sym_x
      REAL(KIND=8), DIMENSION(ns,ns) :: d
      Character(1) :: sym_i, sym_j, sym_d
      if(int.eq.1) then              !  Uk
       sym_i = 's'
       sym_j = 'n'
      elseif(int.eq.2) then          !  QK
       sym_i = 'n'
       sym_j = 'n'
      elseif(int.eq.3) then          !  Tk
       sym_i = 'n'
       sym_j = 'n'
      elseif(int.eq.4) then          !  Mk
       sym_i = 's'
       sym_j = 's'
      elseif(int.eq.5) then          !  Rk
       sym_i = 's'
       sym_j = 's'
      elseif(int.eq.8) then          !  Nk
       sym_i = 's'
       sym_j = 's'
      elseif(int.eq.9) then          !  Vk
       sym_i = 'n'
       sym_j = 's'
      elseif(int.eq.10) then         !  Nk
       sym_i = 's'
       sym_j = 's'
      else
       Stop ' INT_d:  unknown type of integral '
      end if
      sym_d = 'x'
      if(icase.eq.1) sym_d = sym_j
      if(icase.eq.2) sym_d = sym_i
      Call Density (ns,ks,d,p1,p2,sym_d)
      Call Convol  (ns,ks,x,d,icase,sym_i,sym_j)
      sym_x = 'x'
      if(icase.eq.1) sym_x = sym_i
      if(icase.eq.2) sym_x = sym_j
      END SUBROUTINE INT_de


!======================================================================
      Subroutine INT_v(i1,j1,i2,j2,k,int,icase,v)
!======================================================================
!
!                   k                    k
!     Evaluates  INT ( . j1; i2 j2),  INT ( i1 . ; i2 j2),
!                   k                    k
!                INT (i1 j1;  . j2),  INT ( i1 i2; i2  .).
!
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k,int,icase
      REAL(8), INTENT(out), DIMENSION(ns) :: v
      REAL(8), DIMENSION(ns,2*ks-1) :: x
      Character(1) :: sym_x
      if(icase.eq.1) then
        CALL INT_de (p(1,j1),p(1,j2),x,int,1,sym_x)
        CALL bav (ns,ks,x,p(1,i2),v,sym_x,'r')
      elseif(icase.eq.2) then
        CALL INT_de (p(1,i1),p(1,i2),x,int,2,sym_x)
        CALL bav (ns,ks,x,p(1,j2),v,sym_x,'r')
      elseif(icase.eq.3) then
        CALL INT_de (p(1,j1),p(1,j2),x,int,1,sym_x)
        CALL bav (ns,ks,x,p(1,i1),v,sym_x,'l')
      elseif(icase.eq.4) then
        CALL INT_de (p(1,i1),p(1,i2),x,int,2,sym_x)
        CALL bav (ns,ks,x,p(1,j1),v,sym_x,'l')
      end if
      END SUBROUTINE INT_v


!===================================================================
    SUBROUTINE minty(icase,ygr,ym)
!===================================================================
!
!   Computes the array elements   <B_i, y(r) B_j>.
!
!-------------------------------------------------------------------
!
!   on entry
!   --------
!       icase  0 if i >=j (subdiagonals); 1 if i<=j (superdiagonals)
!       ygr    array of values of a specific function  y(r) at the
!              gaussian points of each interval, weighted by the
!              gaussian weights.
!
!   on exit
!   -------
!       ym     <B_i, y(r) B_j> in symmetric lower-band (icase=0) or
!                              upper-band (icase=1) storage mode
!
!--------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: icase
    REAL(KIND=8), DIMENSION(nv,ks), INTENT(IN) :: ygr
    REAL(KIND=8), DIMENSION(ns,ks), INTENT(OUT) :: ym
    ! .. local variables
    INTEGER :: ith, jth, i, irow, jcol
    ym = 0.d0      ! .. clear the ym array
    if (icase /= 0) then
      do ith = 1,ks
        do jth = ith,ks
          jcol = jth-ith+1
          do i = 1,nv
            irow = i+ith-1
            ym(irow,jcol) = ym(irow,jcol)+   &
                  SUM( ygr(i,:)*bsp(i,:,ith)*bsp(i,:,jth) )
          end do
        end do
      end do
    else
      do ith = 1,ks
        do jth = 1,ith
          jcol = jth-ith+ks
          do i = 1,nv
            irow = i+ith-1
            ym(irow,jcol) = ym(irow,jcol)+   &
                SUM( ygr(i,:)*bsp(i,:,ith)*bsp(i,:,jth) )
          end do
        end do
      end do
    end if
  END SUBROUTINE minty


!======================================================================
      REAL(8) FUNCTION mk (i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  M (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mmk_diff or mmk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp
      REAL(8), DIMENSION(ns,ks) :: a,b
      REAL(8) :: mkj
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'mk ') then
       if(meth.eq.'d') then
         Call MMK_diff(k)
       else
         Call MMK_cell(k)
       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'s')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'s')
      ! .. assembling the B-spline integrals
      mk = 0.d0
      do ip = 1,ks
        do i = 1,ns-ip+1
          mkj = 0.d0
          do jp = 1,ks
            do j = 1,ns-jp+1
              mkj = mkj+b(j,jp)*rkb(j,i,jp,ip)
            end do
          end do
          mk = mk + a(i,ip)*mkj
        end do
      end do
      mk = mk / 2.d0  ! ???
      END FUNCTION mk


!======================================================================
      REAL(8) FUNCTION mkc (i1,j1,i2,j2,k)
!======================================================================
!               k
!     Returns  M (i1, j1; i2, j2) - direct summations of moments
!                                   over cells
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ii, ik, ivi,ivj
      REAL(8), DIMENSION(nv) :: v1, v2, v3, v4
      REAL(8), DIMENSION(ks*(ks+1)/2) :: a,b
      REAL(8) :: s1, s2
      !    moments calculations
      Call mk_moments(k)
      ik= ks*(ks+1)/2
      mkc = 0.d0
      Do iv = 1,nv
         ii=0
         Do i=1,ks
          ivi=iv+i-1
          Do j=i,ks
           ivj=iv+j-1
           ii = ii+1
           if(i.eq.j) then
            a(ii) = p(ivi,i1)*p(ivj,i2)
            b(ii) = p(ivi,j1)*p(ivj,j2)
           else
            a(ii) = p(ivi,i1)*p(ivj,i2) + p(ivi,i2)*p(ivj,i1)
            b(ii) = p(ivi,j1)*p(ivj,j2) + p(ivi,j2)*p(ivj,j1)
           end if
          End do
         End do
         v1(iv) = SUM(a*rkd2(1:ik,iv))
         v2(iv) = SUM(b*rkd1(1:ik,iv))
         v3(iv) = SUM(a*rkd1(1:ik,iv))
         v4(iv) = SUM(b*rkd2(1:ik,iv))
         ! .. diagonal contributions
         Do j=1,ik
           mkc = mkc + SUM(a(1:ik)*rkd(1:ik,j,iv))*b(j)
         End do
      End do
      ! the upper and lower regions
      s1 = 0.d0
      s2 = 0.d0
      Do iv = 2,nv
        s1 = s1 + v2(iv-1)
        mkc = mkc + s1*v1(iv)
        s2 = s2 + v3(iv-1)
        mkc = mkc + s2*v4(iv)
      End do
      mkc = mkc / 2 * fine
      End function mkc


!=====================================================================
    SUBROUTINE mkgrid2(ns,ks,z,h,hmax,rmax,t)
!=====================================================================
!   sets up the knots for spline
      IMPLICIT NONE
      Integer(4), intent(in) :: ns,ks
      Real(8), intent(in) :: z,h,hmax,rmax
      Real(8), intent(out), dimension(ns+ks) :: t
! .. Local variables
      INTEGER:: n, i, m, ml, me, me1, me2, nv,nt
      REAL(KIND=8):: hp1, h2, tm, tx, hm
      ! .. determine ml, the number of distinct points from 0 to 1
       ml = 1.d0/h + 0.1
       hp1 = 1.d0 + h
      ! .. determine tmax
      tm = z*rmax
      hm = z*hmax
      ! .. determine final point of "exponential" grid
      ! .. me: number of points from 1 to (1+h)**me
      ! .. m:  number of points from (1+h)**me to tmax
      me1 = MAX(0.0d0, LOG(hm/h)/LOG(hp1)+1.d0)
      me2 = LOG(tm)/LOG(hp1)+1
      IF ( me2 <= me1 ) THEN
        me = me2
        m = 0
      ELSE
        me = me1
        tx = hp1**me
        h2 = h*tx/hp1
        m = NINT((tm-tx)/h2)
      END IF
      n = ml + me + m + ks -1
      if(n.ne.ns) Stop 'mkgrid2: ns <> n '
      nv = ns - (ks -1)
      nt = ns + ks
      ! .. establish the grid for z*r
      t = 0.d0
      DO i = ks+1, ks+ml
        t(i) = t(i-1) + h
      END DO
      DO i = ks+ml+1, ks+me+ml
        t(i) = t(i-1)*hp1
      END DO
      DO i = ks+me+ml+1, n+1
        t(i) = t(i-1) + h2
      END DO
      t(n+2:nt) = t(n+1)
      ! .. scale the values to the R variable
      t = t/z
    END SUBROUTINE mkgrid2


!=======================================================================
      Real(8) Function MKy (I1,J1,I2,J2,K)
!=======================================================================
!                 k
!     Evaluates  M (i1, j1; i2, j2)  =
!
!                 k                      k
!                N (i1, j1; i2, j2)  +  N (j1, i1; j2, i2)    *  1/2  ??
!
!------------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER, INTENT(in) :: I1,J1,I2,J2,K
      REAL(8), EXTERNAL :: NKy
      MKy = NKy(i1,j1,i2,j2,k) + Nky(j1,i1,j2,i2,k)
      MKy = MKy / 2.d0   ! ???
      END Function MKy


!=========================================================================
    SUBROUTINE mk_moments(k)
!=========================================================================
!
!   Defines moments for Mk-integrals in the B-spline cells
!
!   Calling sequence:          mk_moments
!                              ----------
!                               /    \\
!                           moments mk_pdiag
!                                     ||
!                                   mk_triang
!                                    /   \
!                                 gauss  vbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry    k  -  multipole index
!   --------
!
!   on exit     rkd1,rkd2,rkd - off-diagonal and diagonal moments
!   -------                     (in module spline_moments)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_moments
    USE spline_integrals
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_moments
    if(mtype == 'mk ' .and. kmk == k) Return
    CALL moments(  k   , rkd1,'s','b')
    CALL moments(-(k+3), rkd2,'s','b')
    CALL mk_pdiag
    mtype = 'mk '
    kmk = k
    CONTAINS
!===================================================================
    SUBROUTINE mk_pdiag
!===================================================================
!
!   Controls the scaling propeties for diagonal B-spline Nk-interals
!
!   Calls:  mk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER :: iv,ik
    REAL(KIND=8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL mk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region
    DO iv=1,ml+ks-1
      CALL mk_triang(iv)
    END DO
    ! .. the exponential region - using scaling law
    hp=h+1.d0
    ik = ks*(ks+1)/2
    DO iv=ml+ks,ml+me-ks+2
     rkd(1:ik,1:ik,iv) = rkd(1:ik,1:ik,iv-1) / hp
    END DO
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL mk_triang(iv)
    END DO
    END SUBROUTINE mk_pdiag
!========================================================================
    SUBROUTINE mk_triang(iv)
!========================================================================
!
!   Returns the two-dimensional array of B-splin Mk-integrals
!         <B_i B_j| r2^k/r1^(k+3) |B_i' B_j'>
!   over the given triangle diagonal cell
!
!   Calls:   gauss, vbsplvd
!
!   On entry   iv  -  the index of the diagonal cell
!   --------
!
!   On exit    rkd(.,.,iv) - arrays of B-spline Mk-integrals for given
!   --------                 interval iv in the reduced-dimension mode
!                            (in module spline_moments)
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: iv
    ! .. local variables
    INTEGER :: i,j, ip,jp, m,left, ii,jj, ik
    REAL(KIND=8) :: xbase, c
    REAL(KIND=8), DIMENSION(ks) :: x,w, gx,gw
    REAL(KIND=8), DIMENSION(ks,ks) :: bspTmp
    REAL(KIND=8), DIMENSION(ks,ks,ks) ::  Int
    REAL(KIND=8), DIMENSION(nv,ks,ks) :: dbiatx
    REAL(KIND=8), DIMENSION(ks*(ks+1)/2,ks*(ks+1)/2) :: a
    left=iv+ks-1
    xbase=t(left)
    ! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks
! .. the absolute coordinate at the new gaussian point
      gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
      DO i=1,ks
        Call vbsplvd(t,left,1,gx(i),1,dbiatx)
        bspTmp (i,:) = dbiatx(1,:,1)
      END DO
! .. and the corresponding gaussian weights
      gw(:) = (gr(iv,m)-xbase)*w(:) * gx(:)**k
!            / r(iv,m)                             k
! .. Int =  |      bsp(iv,:,j)(r) bsp(iv,:,jp)(r) r  dr
!           / r_iv
      c = grw(iv,m) * grm(iv,m)**(k+3)
      DO j=1,ks
        gx(:) = gw(:)*bspTmp(:,j)
        DO jp=j,ks
          Int(j,jp,m) = SUM(gx(:)*bspTmp(:,jp)) * c
        END DO
      END DO
    END DO    ! over m
! .. second integration ..
    ii = 0
    DO i=1,ks
     DO ip=i,ks
      ii = ii + 1
      gx(:) = bsp(iv,:,i)*bsp(iv,:,ip)
      jj = 0
      DO j=1,ks
       DO jp=j,ks
         jj = jj + 1
         a(ii,jj) = SUM(gx(:)*INT(j,jp,:))
       END DO
      END DO
     END DO
    END DO
    ik = ks*(ks+1)/2
    rkd(1:ik,1:ik,iv) = a + TRANSPOSE(a)
    END SUBROUTINE mk_triang
    END SUBROUTINE mk_moments


!=========================================================================
      SUBROUTINE mmk_cell(k)
!=========================================================================
!
!     Defines matrix of Mk integrals in the B-spline basis
!     by cell algorithm
!
!     Calls: mk_moments
!
!----------------------------------------------------------------------
!
!     on entry      k        multipole index
!     --------
!
!     on exit       rkb     four-dimensional array of Nk integrals
!     -------               of power k in the B-spline basis
!                           (in module spline-integrals)
!
!-------------------------------------------------------------------------
      USE spline_param
      USE spline_moments
      USE spline_integrals
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: k
      INTEGER(4) :: i,j, ii,jj, ip,jp, iv,jv, ih,jh, ihp,jhp
      REAL(8) :: c
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'mk ' .and. krk == k) Return
      ! .. compute the moments in the spline basis
      Call mk_moments(k)
      ! .. generating rbk matrix by summation of moments
      rkb = 0.d0
      DO jv=1,nv
       jj = 0
       DO jh=1,ks
        j = jv + jh - 1
        DO jhp=jh,ks
         jp = jhp - jh + 1
         jj = jj + 1
         DO iv=1,nv
          ii = 0
          DO ih=1,ks
           i = iv + ih -1
           DO ihp=ih,ks
            ip = ihp - ih + 1
            ii = ii + 1
            IF( iv < jv ) THEN
             c = rkd1(ii,iv)*rkd2(jj,jv)
            ELSE IF( iv > jv ) THEN
             c = rkd1(jj,jv)*rkd2(ii,iv)
            ELSE
             c = rkd(ii,jj,iv)
            END IF
            rkb(i,j,ip,jp) = rkb(i,j,ip,jp) + c
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO
      rkb = rkb * fine
      itype = 'mk '
      krk = k
      END SUBROUTINE mmk_cell


!======================================================================
      Subroutine MMK_diff (k)
!======================================================================
!
!     Sets up matrix nk which stores the integral
!
!           <B_isp, (1/r^3)zk{jsp,jsp+jth-1}, B_isp+ith-1>
!         + <B_jsp, (1/r^3)zk{isp,isp+ith-1}, B_jsp+jth-1>
!
!     where isp=1..n, ith=1..ks, and zk{...} is the solution
!     of the differential equation
!
!           (d + k/r)zk(r) = B_jsp(r)*B_jsp+jth-1(r).
!
!   Calling sequence:
!
!                   mmk_diff
!             ------------------
!            /     ||     |    |
!         facdzk bspzk  yval minty
!           |      |
!         dgbfa  dgbsl
!
!
!     on entry
!     --------
!     k    mupltipole index
!
!     on exit
!     -------
!     rbk    a four dimension array nk(isp,jsp,ith,jth)
!            in the symmetric upper-column storage mode
!---------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      USE spline_galerkin
      USE spline_integrals
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: k
      ! .. local variables
      INTEGER :: jsp, jth
      REAL(KIND=8), DIMENSION(ns) :: yk
      REAL(KIND=8), DIMENSION(nv,ks) :: fyk
      REAL(KIND=8), DIMENSION(ns,ks) :: nki
      REAL(KIND=8), DIMENSION(3*ks-2,ns) :: dzk
      INTEGER, DIMENSION(ns) :: ipvtz
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'mk ' .and. krk == k) Return
      ! .. factorize the Zk operator:
      Call FACDZK (3*ks-2,k,dzk,ipvtz)
      rkb = 0.d0
      do jth = 1,ks
      do jsp = 1,ns
        ! ... consider element (jsp,jsp+jth-1) --> (j,j') at j<j'
        if (jsp+jth-1.gt.ns) Exit
        ! ... the coefficients of the B-spline basis for zk{jsp,jth}
        Call BSPZK (jsp,jsp+jth-1)
        ! ... zk{jsp,jth}/r^3 at all the gaussian points (weighted)
        Call YVAL (0,1,-3,yk,fyk)
        ! ... integrates yk with B_isp and B_isp+ith-1 --> superdiagonals
        Call MINTY (1,fyk,nki)
        rkb(:,jsp,1:ks,jth) = rkb(:,jsp,1:ks,jth) + nki(:,:)
        rkb(jsp,:,jth,1:ks) = rkb(jsp,1:ks,jth,:) + nki(:,:)
      end do
      end do
      rkb = rkb * fine
      krk = k
      itype = 'mk '
      CONTAINS
!======================================================================
      Subroutine BSPZK (jf,js)
!======================================================================
!
!     Computes the B-spline expansion for the solution zk
!     of the equation using the spline Galerking method:
!
!       (d + k/r) zk(r)= B_jf*B_js(r),  at is>jf
!
!     Calls:  dgbtrs  (LAPACK) or  dgbsl (LINPACK)
!
!     on entry
!     --------
!     jf   index of the first B-spline
!     js   index of the second B-spline
!
!     on exit
!     -------
!     yk   the coefficients of the B-spline expansion of the solution
!---------------------------------------------------------------------
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: jf,js
       ! .. local variables
       INTEGER :: jv,jv1,jv2, ith, info
       REAL(KIND=8), DIMENSION(ks) :: v
!                                               ks     ks
! ...  the interval stretch of the two splines B     B
!                                               jf     js
       jv1 = max0( 1,js-ks+1)
       jv2 = min0(jf,ns-ks+1)
!  ... set up the array yk = integral of three B-splines  ...
       yk = 0.d0
       do jv = jv1,jv2
        v(:) =  grw(jv,:)*bsp(jv,:,jf-jv+1)*bsp(jv,:,js-jv+1)
        do ith = 1,ks
         yk(jv+ith-1) = yk(jv+ith-1) + SUM(v(:)*bsp(jv,:,ith))
        end do
       end do
! ... boundary condition ...
      yk(1) = 0.d0
      if(k.eq.-1) yk(2)=0.d0
! ... solve the matrix equation ...
!     CALL dgbsl(dzk,3*ks-2,ns,ks-1,ks-1,ipvtz,yk,0)  ! LINPACK
      Call DGBTRS ('N',ns,ks-1,ks-1,1,dzk,3*ks-2,ipvtz,yk,ns,info)
      if(info.ne.0) Stop 'mmk_diff: dgbtrs (LAPACK) failed'
      End Subroutine BSPZK
    End Subroutine mmk_diff


!=========================================================================
      SUBROUTINE mnk_cell(k)
!=========================================================================
!
!     Defines matrix of Nk integrals in the B-spline basis
!     by cell algorithm
!
!     Calls: nk_moments
!
!----------------------------------------------------------------------
!
!     on entry      k        multipole index
!     --------
!
!     on exit       rkb     four-dimensional array of Nk integrals
!     -------               of power k in the B-spline basis
!                           (in module spline-integrals)
!
!-------------------------------------------------------------------------
      USE spline_param
      USE spline_moments
      USE spline_integrals
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: k
      ! .. local variables
      INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
      REAL(8) :: c
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'nk ' .and. krk == k) Return
      ! .. compute the moments in the spline basis
      CALL nk_moments(k)
      ! .. assemble the moments
      rkb=0.d0
      DO iv=1,nv
       ii = 0
       DO ih=1,ks
        i = iv + ih - 1
        DO ihp=ih,ks
         ip = ihp - ih + 1
         ii = ii + 1
         DO jv=1,iv          ! .. jv<=iv
          jj = 0
          DO jh=1,ks
           j = jv + jh - 1
           DO jhp=jh,ks
            jp = jhp - jh + 1
            jj = jj + 1
            IF( jv < iv ) THEN
             c =  rkd2(ii,iv)*rkd1(jj,jv)
            ELSE
             c =  rkd(ii,jj,iv)
            END IF
            rkb(i,j,ip,jp) = rkb(i,j,ip,jp) + c
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO
      rkb = rkb * fine
      itype = 'nk '
      krk = k
      END SUBROUTINE mnk_cell


!======================================================================
      Subroutine MNK_diff (k)
!======================================================================
!
!     Sets up matrix nk which stores the integral
!
!           <B_isp, (1/r^3)zk{jsp,jsp+jth-1}, B_isp+ith-1>
!
!     where isp=1..n, ith=1..ks, and zk{...} is the solution
!     of the differential equation
!
!           (d + k/r)zk(r) = B_jsp(r)*B_jsp+jth-1(r).
!
!   Calling sequence:
!
!                 mnk_diff
!             ------------------
!            /     ||     |    |
!         facdzk bspzk  yval minty
!           |      |
!         dgbfa  dgbsl
!
!
!     on entry
!     --------
!     k    mupltipole index
!
!     on exit
!     -------
!     rbk    a four dimension array nk(isp,jsp,ith,jth)
!            in the symmetric upper-column storage mode
!---------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      USE spline_galerkin
      USE spline_integrals
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: k
      ! .. local variables
      INTEGER :: jsp, jth
      REAL(KIND=8), DIMENSION(ns) :: yk
      REAL(KIND=8), DIMENSION(nv,ks) :: fyk
      REAL(KIND=8), DIMENSION(ns,ks) :: nki
      REAL(KIND=8), DIMENSION(3*ks-2,ns) :: dzk
      INTEGER, DIMENSION(ns) :: ipvtz
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'nk ' .and. krk == k) Return
      ! .. factorize the Zk operator:
      Call FACDZK (3*ks-2,k,dzk,ipvtz)
      do jth = 1,ks
      do jsp = 1,ns
        ! ... consider element (jsp,jsp+jth-1) --> (j,j') at j<j'
        if (jsp+jth-1.gt.ns) Exit
        ! ... the coefficients of the B-spline basis for zk{jsp,jth}
        Call BSPZK (jsp,jsp+jth-1)
        ! ... zk{jsp,jth}/r^3 at all the gaussian points (weighted)
        Call YVAL (0,1,-3,yk,fyk)
        ! ... integrates yk with B_isp and B_isp+ith-1 --> superdiagonals
        Call MINTY (1,fyk,nki)
        rkb(1:ns,jsp,1:ks,jth) = nki(1:ns,1:ks)
      end do
      end do
      rkb = rkb * fine
      krk = k
      itype = 'nk '
      CONTAINS
!======================================================================
      Subroutine BSPZK (jf,js)
!======================================================================
!
!     Computes the B-spline expansion for the solution zk
!     of the equation using the spline Galerking method:
!
!       (d + k/r) zk(r)= B_jf*B_js(r),  at is>jf
!
!     Calls:  dgbtrs  (LAPACK) or  dgbsl (LINPACK)
!
!     on entry
!     --------
!     jf   index of the first B-spline
!     js   index of the second B-spline
!
!     on exit
!     -------
!     yk   the coefficients of the B-spline expansion of the solution
!---------------------------------------------------------------------
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: jf,js
       ! .. local variables
       INTEGER :: jv,jv1,jv2, ith, info
       REAL(KIND=8), DIMENSION(ks) :: v
!                                               ks     ks
! ...  the interval stretch of the two splines B     B
!                                               jf     js
       jv1 = max0( 1,js-ks+1)
       jv2 = min0(jf,ns-ks+1)
!  ... set up the array yk = integral of three B-splines  ...
       yk = 0.d0
       do jv = jv1,jv2
        v(:) =  grw(jv,:)*bsp(jv,:,jf-jv+1)*bsp(jv,:,js-jv+1)
        do ith = 1,ks
         yk(jv+ith-1) = yk(jv+ith-1) + SUM(v(:)*bsp(jv,:,ith))
        end do
       end do
! ... boundary condition ...
      yk(1) = 0.d0
      if(k.eq.-1) yk(2)=0.d0
! ... solve the matrix equation ...
!     CALL dgbsl(dzk,3*ks-2,ns,ks-1,ks-1,ipvtz,yk,0) ! LINPACK
      Call DGBTRS ('N',ns,ks-1,ks-1,1,dzk,3*ks-2,ipvtz,yk,ns,info)
      if(info.ne.0) Stop 'MNK_diff: dgbtrs (LAPACK) failed'
      End Subroutine BSPZK
    End Subroutine MNK_diff


!=====================================================================
    SUBROUTINE  moments (k,rkm,sym,dir)
!=====================================================================
!
!   Computes moments defining as <B_i|r^k|B_j> over an interval
!
!---------------------------------------------------------------------
!
!   on entry
!   --------
!      k      the power of moments
!      sym    's' or 'n' - symmetrical or non-symetrical case
!      div    'b' or 'd' - B_j or B'_j
!
!   on exit
!   -------
!
!      rkm    array of moments for every interval 'iv'
!
!---------------------------------------------------------------------
      USE spline_param
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: k
      REAL(8), DIMENSION(ks*ks,nv), INTENT(out) :: rkm
      CHARACTER(1), INTENT(in) :: sym, dir
      ! .. local variables
      INTEGER :: iv, jk
      REAL(KIND=8) :: hp
      REAL(KIND=8), DIMENSION(ks*ks) :: rv
      jk = ks*(ks+1)/2
      if(sym.eq.'n') jk=ks*ks
      if(me.eq.0) then     ! .. there is no exponential grid
       Do iv = 1,nv
        Call moment(iv,k,rv,sym,dir)
        rkm(1:jk,iv) = rv(1:jk)
       End do
      else                 ! .. case of exponential grid
       ! .. the first non-exponential region
       DO iv = 1,ml+ks-1
        Call moment(iv,k,rv,sym,dir)
        rkm(1:jk,iv) = rv(1:jk)
       END DO
       ! .. the exponential region --- using scaling law
       hp = (1.d0+h)**k
       if(dir.eq.'b') hp = hp*(1.d0+h)
       DO iv=ml+ks,ml+me-ks+2
        rkm(1:jk,iv) = rkm(1:jk,iv-1)*hp
       END DO
       ! .. the last non-exponential region
       DO iv=ml+me-ks+3,nv
        Call moment(iv,k,rv,sym,dir)
        rkm(1:jk,iv) = rv(1:jk)
       END DO
      end if
      END SUBROUTINE moments
!=====================================================================
    SUBROUTINE  moment (iv,k,rv,sym,dir)
!=====================================================================
!
!   Computes moment defining as <B_i|r^k|B_j> for given interval
!
!---------------------------------------------------------------------
!
!   on entry
!   --------
!      k      the power of moments
!      sym    's' or 'n' - symmetrical or non-symetrical case
!      div    'b' or 'd' - B_j or B'_j
!      iv     index of interval
!
!   on exit
!   -------
!
!      rv     array of moments for given interval 'iv'
!
!---------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: k,iv
      REAL(8), DIMENSION(ks*ks), INTENT(out) :: rv
      Character(1), INTENT(in) :: sym, dir
      ! .. local variables
      INTEGER(4) :: i, j, ii, jj
      REAL(8), DIMENSION(ks) :: gw
      REAL(8), DIMENSION(ks,ks) :: bi,bj
      gw = grw(iv,:)
      if( k > 0 ) gw = grw(iv,:) * gr (iv,:)**(+k)
      if( k < 0 ) gw = grw(iv,:) * grm(iv,:)**(-k)
      bi(:,:) = bsp(iv,:,:)
      Do j = 1,ks
       if(dir.eq.'b') then
        bj(:,j) = bsp(iv,:,j)*gw(:)
       else
        bj(:,j) = bsq(iv,:,j)*gw(:)
       end if
      End do
      ii = 0
      DO i=1,ks
       jj = 1; if(sym.eq.'s') jj = i
       DO j=jj,ks
        ii = ii + 1
        rv(ii) = SUM(bi(:,i)*bj(:,j))
       END DO
      END DO
      END SUBROUTINE moment


!=========================================================================
    SUBROUTINE mqk_cell(k)
!=========================================================================
!
!   Defines matrix of Qk integrals in the B-spline basis by cell algorithm
!
!   Calls: qk_moments
!
!-------------------------------------------------------------------------
!
!   on entry
!   --------
!       k     multipole index
!
!   on exit
!   -------
!      rkb    four-dimensional array of qk integrals of power k in
!             the Spline basis (in module spline-integrals)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_integrals
    USE spline_moments
    USE spline_atomic
    IMPLICIT NONE
    INTEGER, INTENT(in) :: k
    ! .. local variables
      INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
      REAL(8) :: c
    ! .. check the need of calculations
    if(itype == 'aaa') Call allocate_integrals
    if(itype == 'qk ' .and. krk == k) Return
    ! .. compute the moments in the spline basis
    Call qk_moments(k)
    ! .. assemble the moments
    rkb = 0.d0
    DO jv=1,nv
      jj = 0
      DO jh=1,ks
        j = jv + jh - 1
        DO jhp=1,ks
          jp = jhp - jh + ks
          jj = jj + 1
          DO iv=1,nv
            ii = 0
            DO ih=1,ks
              i = iv + ih -1
              DO ihp=1,ks
               ip = ihp - ih + ks
               ii = ii + 1
         IF( iv < jv ) THEN
                  c  = rkd3(ii,iv)*rkd2(jj,jv)
         ELSE IF( iv > jv ) THEN
                  c  = rkd1(jj,jv)*rkd4(ii,iv)
         ELSE
                  c  = rkd(ii,jj,iv)
         END IF
                  rkb(i,j,ip,jp) = rkb(i,j,ip,jp)  + c
                  rkb(j,i,jp,ip) = rkb(j,i,jp,ip)  - c
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    rkb = rkb * fine
    itype = 'qk '
    krk = k
    END SUBROUTINE mqk_cell


!======================================================================
      SUBROUTINE mrk_cell(k)
!======================================================================
!
!     Defines matrix of Rk integrals in the B-spline basis
!     by cell algorithm
!
!     Calls: rk_moments
!
!----------------------------------------------------------------------
!
!     on entry      k        multipole index
!     --------
!
!     on exit       rkb     four-dimensional array of Slater integrals
!     -------               of power k in the B-spline basis
!                           (in module spline-integrals)
!----------------------------------------------------------------------
      USE spline_param
      USE spline_integrals
      USE spline_moments
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: k
      ! .. local variables
      INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
      REAL(8) :: c
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'rk ' .and. krk == k) Return
      ! .. compute the moments in the spline basis
      CALL rk_moments(k)
      ! .. generate the rkb array
      rkb=0.d0
      DO jv=1,nv
       jj = 0
       DO jh=1,ks
        j = jv + jh - 1
        DO jhp=jh,ks
         jp = jhp - jh + 1
         jj = jj + 1
         DO iv=1,nv
          ii = 0
          DO ih=1,ks
           i = iv + ih -1
           DO ihp=ih,ks
            ip = ihp - ih + 1
            ii = ii + 1
            if( iv < jv ) then
             c = rkd1(ii,iv)*rkd2(jj,jv)
            else if( iv > jv ) then
             c = rkd1(jj,jv)*rkd2(ii,iv)
            else
             c = rkd(ii,jj,iv)
            end if
            rkb(i,j,ip,jp) = rkb(i,j,ip,jp) +  c
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO
      itype='rk '
      krk=k
      END SUBROUTINE mrk_cell


!=====================================================================
    SUBROUTINE mrk_diff(k)
!=====================================================================
!
!   Sets up matrix rk which stores the integral
!                1
!       <B_isp  ---  yk{jsp,jth} B_isp+ith-1>
!                r
!   where isp=1..n, ith=1..ks, and yk{jsp,jth} is the solution
!   of the differential equation:
!
!        d^2    k(k+1)         (2k+1)
!       (--- - ------)yk(r)= - ------ B_jsp(r) B_jsp+jth-1(r).
!        dr^2    r^2              r
!
!-----------------------------------------------------------------------
!
!     Calling sequence:
!
!                mrk
!                 |
!         ------------------
!        /     ||     |    |
!     facdyk bspyk  yval minty
!       |      |
!     dgbfa  dgbsl
!
!---------------------------------------------------------------------
!     on entry
!     --------
!     k    mupltipole index
!
!     on exit
!     -------
!     rbk    a four dimension array rk(isp,jsp,ith,jth)
!            in the symmetric upper-column storage mode
!---------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_integrals
    USE spline_atomic
    IMPLICIT NONE
    INTEGER, INTENT(in) :: k
    ! .. local variables
    INTEGER ::  isp, ith, jsp, jth, jv, jv1,jv2
    REAL(KIND=8), DIMENSION(ns) :: yk
    REAL(KIND=8), DIMENSION(nv,ks) :: fyk
    REAL(KIND=8), DIMENSION(ns,ks) :: rki
    REAL(KIND=8), DIMENSION(3*ks-2,ns) :: dyk
    REAL(KIND=8) :: c
    INTEGER, DIMENSION(ns) :: ipvtd
!---------------------------------------------------------------------
    ! .. check the need of calculations
    if(itype == 'aaa') Call allocate_integrals
    if(itype == 'rk ' .and. krk == k) Return
!---------------------------------------------------------------------
    ! .. set up and factorize the differential operator
    CALL facdyk(3*ks-2,k,ipvtd,dyk)
    DO ith = 1,ks
      DO isp = 1,ns
        jsp = isp+ith-1
        ! ... consider element (isp,jsp) --> (j,j') at j<j'
        if (jsp > ns) EXIT
        ! .. B-spline represantation for yk{isp,ith}
        CALL bspyk(isp,jsp)
        ! .. evaluates the function yk{isp,ith} at all the gaussian points
        CALL yval(0,1,-1,yk,fyk)
         IF (rel) THEN
           c = (2*k+1)*fine
           jv1 = max0(  1,jsp-ks+1)
           jv2 = min0(isp, ns-ks+1)
           do jv = jv1,jv2
              fyk(jv,:) = fyk(jv,:) + c*grw(jv,:)*grm(jv,:)*grm(jv,:)*  &
                          bsp(jv,:,isp-jv+1)*bsp(jv,:,jsp-jv+1)
           end do
         END IF
        ! .. integrates yk with B_jsp and B_jsp+jth-1; superdiagonals
        CALL minty(1,fyk,rki)
        rkb(1:ns,isp,1:ks,ith) = rki(1:ns,1:ks)
      END DO
    END DO
    itype='rk '
    krk=k
    CONTAINS
!======================================================================
    SUBROUTINE bspyk(jf,js)
!======================================================================
!
!   Computes the B-spline expansion for the solution yk
!   of the equation using the spline Galerking method:
!
!       (d^2-k(k+1)/r^2) yk(r) = -(2k+1) B_jf(r) B_js(r)/r
!
!   with boundary conditions:
!       at r=0, yk(r) = 0;
!       at r=rmax, yk(r) = const(=ykbc), if k=0,
!                  dy/dr + (k/r)y = B_jf(r) B_js(r) if k>0.
!
!   SUBROUTINES called:    dgbsl (LINPACK)
!
!---------------------------------------------------------------------
!
!   on entry
!   --------
!       jf    index of the first B-spline
!       js    index of the second B-spline
!
!   on exit
!   -------
!       yk    the coefficients of the B-spline expansion of yk(r)
!
!---------------------------------------------------------------------
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: jf,js
       ! .. local variables
       REAL(8), DIMENSION(ks) :: v
       Integer(4) :: info
!                                               ks     ks
! ...  the interval stretch of the two splines B     B
!                                               jf     js
       jv1 = max0( 1,js-ks+1)
       jv2 = min0(jf,ns-ks+1)
!  ... set up the array yk = integral of three B-splines / r ...
       yk = 0.d0
       do jv = jv1,jv2
        v(:) =  grw(jv,:)*grm(jv,:)*bsp(jv,:,jf-jv+1)*bsp(jv,:,js-jv+1)
        do jth = 1,ks
         yk(jv+jth-1) = yk(jv+jth-1) + SUM(v(:)*bsp(jv,:,jth))
        end do
       end do
       c = -(2*k+1)
       yk = c*yk
       ! .. the boundary condition at the origin
       yk(1) = 0.d0
       ! .. the boundary condition at rmax
       if (k == 0) then
         yk(ns) = sb(js,jf-js+ks)
       else
         yk(ns) = 0.0d0
         if(js==ns .and. jf==ns) yk(ns) = 1.d0
       end if
       ! .. solve the matrix equation
!      CALL dgbsl(dyk,3*ks-2,ns,ks-1,ks-1,ipvtd,yk,0) ! LINPACK
      Call DGBTRS ('N',ns,ks-1,ks-1,1,dyk,3*ks-2,ipvtd,yk,ns,info)
      if(info.ne.0) Stop 'mrk_diff: dgbtrs (LAPACK) failed'
     END SUBROUTINE bspyk
  END SUBROUTINE mrk_diff


!=======================================================================
    SUBROUTINE mrm(mm,rm)
!=======================================================================
!
!   Computes the matrix representation of the operator
!
!             r^mm
!
!   in the B-spline basis.
!
!-----------------------------------------------------------------------
!
!   on entry
!   --------
!       mm      integer defining the power of r
!
!   on exit
!   -------
!       rm      <B_i,r^mm B_j> in symmetric storage mode
!
!-----------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    IMPLICIT NONE
    REAL(KIND=8), DIMENSION(ns,ks), INTENT(OUT) :: rm
    INTEGER, INTENT(IN) :: mm
    ! .. local variables
    INTEGER :: i, irow, jcol, ith, jth
    ! .. clear the rm array
    rm = 0.d0
    ! .. assemble the matrix elements
    if (mm == 0) then
      do  ith=1,ks
        do jth=1,ith
          jcol=jth-ith+ks
          do i=1,nv
            irow=i+ith-1
            rm(irow,jcol)=rm(irow,jcol) &
              + SUM(grw(i,:)*bsp(i,:,ith)*bsp(i,:,jth))
          end do
        end do
      end do
    else if (mm == -1) then
      do ith=1,ks
        do jth=1,ith
          jcol=jth-ith+ks
          do i=1,nv
            irow=i+ith-1
            rm(irow,jcol)=rm(irow,jcol) &
              + SUM(grw(i,:)*bsp(i,:,ith)*grm(i,:)*bsp(i,:,jth))
          end do
        end do
      end do
    else if (mm <= -2) then
      do ith=1,ks
        do jth=1,ith
          jcol=jth-ith+ks
          do i=1,nv
            irow=i+ith-1
            rm(irow,jcol)=rm(irow,jcol) &
              + SUM(grw(i,:)*bsp(i,:,ith)*grm(i,:)**(-mm)*bsp(i,:,jth))
          end do
        end do
      end do
    else if (mm == 1) then
      do ith=1,ks
        do jth=1,ith
          jcol=jth-ith+ks
          do i=1,nv
            irow=i+ith-1
            rm(irow,jcol)=rm(irow,jcol) &
             + SUM(grw(i,:)*bsp(i,:,ith)*gr(i,:)*bsp(i,:,jth))
          end do
        end do
      end do
    else if (mm >= 2) then
      do ith=1,ks
        do jth=1,ith
          jcol=jth-ith+ks
          do i=1,nv
            irow=i+ith-1
            rm(irow,jcol)=rm(irow,jcol) &
             + SUM(grw(i,:)*bsp(i,:,ith)*gr(i,:)**mm*bsp(i,:,jth))
          end do
        end do
      end do
    end if
  END SUBROUTINE mrm


!=========================================================================
      SUBROUTINE mtk_cell(k)
!=========================================================================
!
!     Defines matrix of Tk integrals in the B-spline basis
!     by cell algorithm
!
!     Calls: tk_moments
!
!----------------------------------------------------------------------
!
!     on entry      k        multipole index
!     --------
!
!     on exit       rkb     four-dimensional array of Tk integrals
!     -------               of power k in the B-spline basis
!                           (in module spline-integrals)
!-------------------------------------------------------------------------
      USE spline_param
      USE spline_atomic
      USE spline_integrals
      USE spline_moments
      IMPLICIT NONE
      INTEGER, INTENT(in) :: k
      ! .. local variables
      INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
      REAL(8) :: c
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'tk ' .and. krk == k) Return
      ! .. compute the moments in the spline basis
      CALL tk_moments(k)
      ! .. assemble the moments
      rkb = 0.d0
      DO jv=1,nv
       jj = 0
       DO jh=1,ks
        j = jv + jh - 1
        DO jhp=1,ks
         jp = jhp - jh + ks
         jj = jj + 1
         DO iv=1,nv
          ii = 0
          DO ih=1,ks
           i = iv + ih -1
           DO ihp=1,ks
            ip = ihp - ih + ks
            ii = ii + 1
            IF( iv < jv ) THEN
             c = rkd1(ii,iv)*rkd2(jj,jv)
            ELSE IF ( iv > jv ) THEN
             c = rkd1(jj,jv)*rkd2(ii,iv)
            ELSE
             c = rkd(ii,jj,iv)
            END IF
            rkb(i,j,ip,jp) = rkb(i,j,ip,jp) + c
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO
      c = fine / (k+k+1)
      rkb = rkb * c
      itype = 'tk '
      krk = k
      END SUBROUTINE mtk_cell


!=====================================================================
    SUBROUTINE mtk_diff(k)
!=====================================================================
!
!   Sets up matrix tk which stores the integral
!                 1
!       <B_isp  ---  yk{jsp,jth} B'_isp+ith-1>
!                 r
!   where isp=1..n, ith=1..ks, and yk{jsp,jth} is the solution
!   of the differential equation:
!
!        d^2    k(k+1)         (2k+1)
!       (--- - ------)yk(r)= - ------ B_jsp(r) B'_jsp+jth-1(r).
!        dr^2    r^2              r
!
!-----------------------------------------------------------------------
!
!     Calling sequence:
!
!                mtk
!                 |
!         ------------------
!        /     ||     |    |
!     facdyk bsptyk  yval dinty
!       |      |
!     dgbfa  dgbsl
!
!---------------------------------------------------------------------
!     on entry
!     --------
!     k    mupltipole index
!
!     on exit
!     -------
!     rbk    a four dimension array rk(isp,jsp,ith,jth)
!            in the symmetric upper-column storage mode
!---------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_integrals
    USE spline_atomic
    IMPLICIT NONE
    INTEGER, INTENT(in) :: k
    ! .. local variables
    INTEGER ::  isp, ith, jsp, jth, jv, jv1,jv2
    REAL(KIND=8), DIMENSION(ns) :: yk
    REAL(KIND=8), DIMENSION(nv,ks) :: fyk
    REAL(KIND=8), DIMENSION(ns,2*ks-1) :: tk, tkd
    REAL(KIND=8), DIMENSION(3*ks-2,ns) :: dyk
    REAL(KIND=8) :: c
    INTEGER, DIMENSION(ns) :: ipvtd
!---------------------------------------------------------------------
    ! .. check the need of calculations
    if(itype == 'aaa') Call allocate_integrals
    if(itype == 'tk ' .and. krk == k) Return
!---------------------------------------------------------------------
    ! .. set up and factorize the differential operator
    CALL facdyk(3*ks-2,k,ipvtd,dyk)
    DO ith = 1,2*ks-1
      DO isp = 1,ns
        jsp = isp+ith-ks
        ! ... consider element (isp,jsp) --> (j,j') at j<j'
        if (jsp > ns) EXIT
        ! .. B-spline represantation for yk{isp,ith}
        CALL bsptyk(isp,jsp)
        ! .. yk{jsp,jth}/r at all the gaussian points (weighted)
        Call YVAL (0,1,-1,yk,fyk)
        ! .. integrates yk with B_isp and B'_isp+ith-1 for all elements
        Call DINTY (1,fyk,tkd)
        ! .. yk{isp,ith}/r^2 at all the gaussian points (weighted)
        Call YVAL (0,1,-2,yk,fyk)
        ! .. integrates yk with B_isp and B_isp+ith-1 for all elements
        Call DINTY (0,fyk,tk)
        rkb(:,isp,:,ith) = tkd(:,:) - tk(:,:)
      END DO
    END DO
    c = fine / (k+k+1)
    rkb = rkb * c
    itype='tk '
    krk=k
    CONTAINS
!======================================================================
    SUBROUTINE bsptyk(jf,js)
!======================================================================
!
!   Computes the B-spline expansion for the solution yk
!   of the equation using the spline Galerking method:
!
!       (d^2-k(k+1)/r^2) yk(r) = -(2k+1) B_jf(r) B'_js(r)/r
!
!   with boundary conditions:
!       at r=0, yk(r) = 0;
!       at r=rmax, yk(r) = const, if k=0,
!                  dy/dr + (k/r)y = B_jf(r) B'_js(r) if k>0.
!
!   SUBROUTINES called:    dgbsl (LINPACK)
!
!---------------------------------------------------------------------
!
!   on entry
!   --------
!       jf    index of the first B-spline
!       js    index of the second B-spline
!
!   on exit
!   -------
!       yk    the coefficients of the B-spline expansion of yk(r)
!
!---------------------------------------------------------------------
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: jf,js
       ! .. local variables
       REAL(8), DIMENSION(ks) :: v
       INTEGER(4) :: info
!                                               ks     ks
! ...  the interval stretch of the two splines B     B
!                                               jf     js
       jv1 = max0( 1,jf-ks+1,js-ks+1)
       jv2 = min0(jf,js,ns-ks+1)
!  ... set up the array yk  ...
       yk = 0.d0
       do jv = jv1,jv2
        v(:) =  grw(jv,:)*grm(jv,:)*bsp(jv,:,jf-jv+1)*     &
                (bspd(jv,:,js-jv+1,1) - grm(jv,:)*bsp(jv,:,js-jv+1))
        do jth = 1,ks
         yk(jv+jth-1) = yk(jv+jth-1) + SUM(v(:)*bsp(jv,:,jth))
        end do
       end do
       c = -(2*k+1)
       yk = c*yk
       ! .. the boundary condition at the origin
       yk(1) = 0.d0
       ! .. the boundary condition at rmax
       if (k == 0) then
         if(js.gt.jf) then
          yk(ns) = db1(js,jf-js+ks) - rm1(js,jf-js+ks)
         else
          yk(ns) = -db1(jf,js-jf+ks) - rm1(jf,js-jf+ks)
         end if
       else
         if(jf.ne.ns) then
          yk(ns) = 0.d0
         elseif(js.eq.ns) then
          yk(ns) = bspd(nv+1,1,ks,1) - 1.d0/t(ns+1)
         elseif(js.eq.ns-1) then
          yk(ns) = bspd(nv+1,1,ks-1,1)
         end if
       end if
       ! .. solve the matrix equation
!      CALL dgbsl(dyk,3*ks-2,ns,ks-1,ks-1,ipvtd,yk,0) ! LINPACK
       Call DGBTRS ('N',ns,ks-1,ks-1,1,dyk,3*ks-2,ipvtd,yk,ns,info)
       if(info.ne.0) Stop 'mtk_diff: dgbtrs (LAPACK) failed'
     END SUBROUTINE bsptyk
  END SUBROUTINE mtk_diff


!====================================================================
    SUBROUTINE mvc(l)
!====================================================================
!
!   Computes the matrix elements for the mass-velocity correction
!   in the B-spline basis.  The lack of symmetry in the d^2/dr^2
!   operator is ignored.
!
!     VC(i,j) = INT [  (d^2/dr^2 - l(l+1)/r) B_i(r) *
!                      (d^2/dr^2 - l(l+1)/r) B_j(r)  ] dr
!--------------------------------------------------------------------
!
!   on entry
!   --------
!       l    the angular momentum
!
!   on exit
!   -------
!       vc   the mass velocity correction in symmetric storage mode
!
!--------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_atomic
    USE spline_hl
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: l
    ! .. local variables
    INTEGER :: m, ith, jth, i, irow, jcol
    REAL(KIND=8) :: fll, y1, y2, S, B
    ! .. initialize the vc array
    vc = 0.d0
    fll  =  l*(l+1)
    ! .. compute the matrix elements
    do m = 1,ks
      do i = 1,nv
        S = fll*grm(i,m)*grm(i,m)
! ... cutoff correction
!        B = gr(i,m)/(gr(i,m)+2*fine*Z)
!        B = B*B*B
        do ith = 1,ks
          irow = i+ith-1
          do jth = 1,ith
          jcol = jth-ith+ks
            y1 = bspd(i,m,ith,2) - S*bsp(i,m,ith)
            y2 = bspd(i,m,jth,2) - S*bsp(i,m,jth)
            vc(irow,jcol) = vc(irow,jcol) + grw(i,m)*y1*y2 !*B
          end do
        end do
      end do
    end do
    END SUBROUTINE mvc


!====================================================================
    SUBROUTINE mvcv(l,vc)
!====================================================================
!
!   Computes the matrix elements for the mass-velocity correction
!   in the B-spline basis.  The lack of symmetry in the d^2/dr^2
!   operator is ignored.
!
!     VC(i,j) = INT [  (d^2/dr^2 - l(l+1)/r) B_i(r) *
!                      (d^2/dr^2 - l(l+1)/r) B_j(r)  ] dr
!--------------------------------------------------------------------
!
!   on entry
!   --------
!       l    the angular momentum
!
!   on exit
!   -------
!       vc   the mass velocity correction in symmetric storage mode
!
!--------------------------------------------------------------------
    USE spline_param; USE spline_atomic;  USE spline_grid
    IMPLICIT NONE
    INTEGER(4), INTENT(in) :: l
    REAL(8), INTENT(inout), Dimension(ns,ks) :: vc
    INTEGER(4) :: m, ith, jth, i, irow, jcol
    REAL(8) :: fll, y1, y2, S, B
    Real(8), External :: AZL
    ! .. initialize the vc array
    vc = 0.d0;  fll = l*(l+1);  nv = ns-ks+1
    ! .. compute the matrix elements
    do m = 1,ks
      do i = 1,nv
        S = fll*grm(i,m)*grm(i,m)
! ... cutoff correction
!        B = gr(i,m)/(gr(i,m)+2*fine*Z);  B = B*B*B
        do ith = 1,ks
          irow = i+ith-1
          do jth = 1,ith
          jcol = jth-ith+ks
            y1 = bspd(i,m,ith,2) - S*bsp(i,m,ith)
            y2 = bspd(i,m,jth,2) - S*bsp(i,m,jth)
            vc(irow,jcol) = vc(irow,jcol) + grw(i,m)*y1*y2 !* B
          end do
        end do
      end do
    end do
    vc = vc * fine
! ... one-electron Darwin correction:
    if(l.eq.0) then
      S = azl(z,h,ks,l+1);  vc(2,ks) = vc(2,ks) - z*S*S*fine
    end if
    END SUBROUTINE mvcv


!=========================================================================
      SUBROUTINE mvk_cell(k)
!=========================================================================
!
!     Defines matrix of Vk integrals in the B-spline basis
!     by cell algorithm
!
!     Calls: vk_moments
!----------------------------------------------------------------------
!
!     on entry      k        multipole index
!     --------
!
!     on exit       rkb     four-dimensional array of Vk integrals
!     -------               of power k in the B-spline basis
!                           (in module spline-integrals)
!-------------------------------------------------------------------------
      USE spline_param
      USE spline_integrals
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: k
      ! .. local variables
      INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
      REAL(8) :: c
      ! .. check the need of calculations
      if(itype == 'aaa') Call allocate_integrals
      if(itype == 'vk ' .and. krk == k) Return
      ! .. compute the moments in the spline basis
      CALL vk_moments(k)
      ! .. assemble the moments
      rkb = 0.d0
      DO jv=1,nv
       jj = 0
       DO jh=1,ks
        j = jv + jh - 1
        DO jhp=jh,ks
         jp = jhp - jh + 1
         jj = jj + 1
         DO iv=1,nv
          ii = 0
          DO ih=1,ks
           i = iv + ih - 1
           DO ihp=1,ks
            ip = ihp - ih + ks
            ii = ii + 1
            IF( iv < jv ) THEN
             c  =  rkd3(ii,iv)*rkd2(jj,jv)
            ELSE IF( iv > jv ) THEN
             c  =  rkd1(jj,jv)*rkd4(ii,iv)
            ELSE
             c  =  rkd(ii,jj,iv)
            END IF
            rkb(i,j,ip,jp) = rkb(i,j,ip,jp) + c
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO
      rkb = rkb * fine
      itype = 'vk '
      krk = k
      END SUBROUTINE mvk_cell


!======================================================================
      Subroutine MVK_diff(k)
!======================================================================
!
!     Sets up matrix vk which stores the integral
!
!           <B_isp, (1/r^3) yk{jsp,jsp+jth-1}, B'_isp+ith-1>
!
!     where isp=1..n, ith=1..ks, and yk{...} is the solution
!     of the differential equation
!
!           (d - (k+3)/r) yk(r) = -(2k+3)/r * Zk
!
!     and zk{...} is the solution  of the differential equation
!
!           (d + k/r)zk(r) = r * B_jsp(r)*B_jsp+jth-1(r).
!
!-----------------------------------------------------------------------
!
!     Calling sequence:
!
!                mvk
!                 |
!          -----------------
!         /     ||     |    \
!      facdzk bspvyk  yval dinty
!        |       |
!      dgbfa   ----------
!             /     |    \
!            yval  vinty  dgbsl
!-----------------------------------------------------------------------
!     on entry
!     --------
!     k    multipole index
!
!     on exit
!     -------
!     rkb   a four dimension array vk(isp,jsp,ith,jth)
!           in symmetric upper-column storage mode for j-indeces
!           and non-symmetric storage mode for i-indeces
!=====================================================================
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_integrals
    USE spline_atomic
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    ! .. local variables
    INTEGER :: jsp, jth
    REAL(KIND=8),DIMENSION(ns) :: yk
    REAL(KIND=8),DIMENSION(ns,2*ks-1) :: vk, vkd
    REAL(KIND=8),DIMENSION(nv,ks) :: fyk
    REAL(KIND=8),DIMENSION(3*ks-2,ns) :: dyk,dzk
    INTEGER, DIMENSION(ns) :: ipvtz,ipvty
    ! .. check the need of calculations
    if(itype == 'aaa') Call allocate_integrals
    if(itype == 'vk ' .and. krk == k) Return
    ! .. factorize the diff. operators
    Call FACDZK  (3*ks-2,  k   ,dzk,ipvtz)
    Call FACDZK  (3*ks-2,-(k+3),dyk,ipvty)
    do jth = 1,ks
    do jsp = 1,ns
      ! .. consider element (jsp,jsp+jth-1) --> (j,j') at j<=j'
      if (jsp+jth-1 .gt. ns) Exit
      ! .. B-spline represantation for yk{jsp,jth}
      Call BSPVYK (jsp,jsp+jth-1)
      ! .. yk{jsp,jth}/r^3 at all the gaussian points (weighted)
      Call YVAL (0,1,-3,yk,fyk)
      ! .. integrates yk with B_isp and B'_isp+ith-1 for all elements
      Call DINTY (1,fyk,vkd)
      ! .. yk{isp,ith}/r^4 at all the gaussian points (weighted)
      Call YVAL (0,1,-4,yk,fyk)
      ! .. integrates yk with B_isp and B_isp+ith-1 for all elements
      Call DINTY (0,fyk,vk)
      rkb(:,jsp,:,jth) = vkd(:,:) - vk(:,:)
    end do
    end do
    rkb = rkb * fine
    krk = k
    itype = 'vk '
    CONTAINS
!======================================================================
      Subroutine BSPVYK (jf,js)
!======================================================================
!
!     Computes the B-spline expansion for the solution yk
!
!     (d-(k+3)/r) yk(r)= -(2k+3)/r zk,  where
!
!     (d + k/r)zk(r) = r * B_is(r)*B_if(r), at is>jf
!
!     on entry
!     --------
!     jf   index of the first B-spline
!     js   index of the second B-spline
!
!     on exit
!     -------
!     yk   coefficients of the B-spline expansion of the solution
!
!     Calls: YVAL, VINTY,  dgbtrs (LAPPACK)  or  dgbsl (LINPACK)
!---------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: jf,js
    ! .. local variables
    INTEGER :: jv,jv1,jv2, ith, info
    REAL(8), DIMENSION(ks) :: v
    REAL(8) :: yns
!----------------------------------------------------------------------
!                                                          zk-function:
!                                             ks     ks
! .. the interval stretch of the two splines B     B
!                                             jf     js
       jv1 = max0( 1,js-ks+1)
       jv2 = min0(jf,ns-ks+1)
!  ... set up the array yk = integral of three B-splines * r ...
       yk = 0.d0
       do jv = jv1,jv2
        v(:) =  grw(jv,:)*gr(jv,:)*bsp(jv,:,jf-jv+1)*bsp(jv,:,js-jv+1)
        do ith = 1,ks
         yk(jv+ith-1) = yk(jv+ith-1) + SUM(v(:)*bsp(jv,:,ith))
        end do
       end do
!  ... boundary condition ...
       yk(1) = 0.d0
!  ... solve the matrix equation ...
!      CALL dgbsl(dzk,3*ks-2,ns,ks-1,ks-1,ipvtz,yk,0) ! LINPACK
       Call DGBTRS ('N',ns,ks-1,ks-1,1,dzk,3*ks-2,ipvtz,yk,ns,info)
       if( info .ne. 0 ) Stop 'BSPVYK: dgbtrs failed (LAPACK)'
!----------------------------------------------------------------------
!                                                          yk-function:
       yns = yk(ns)
!  ... set up the array of yk(i) = INTEGRAL '1/r zk(r) B_i(r)'
!  ... (1/r)zk(r) at all the gaussian points (weighted)
       Call YVAL (0,1,-1,yk,fyk)
       Call Vinty(fyk,yk)
       yk = - (k+k+3) * yk
!  ... boundary conditions:
       yk(1)  = 0.d0
       yk(ns) = yns
!  ... solve the matrix equation
!      CALL dgbsl(dyk,3*ks-2,ns,ks-1,ks-1,ipvty,yk,0)  ! LINPACK
       Call DGBTRS ('N',ns,ks-1,ks-1,1,dyk,3*ks-2,ipvty,yk,ns,info)
       if(info.ne.0) Stop 'BSPVYK: dgbtrs (LAPACK) failed'
       End Subroutine BSPVYK
      End Subroutine MVK_diff


!=========================================================================
    SUBROUTINE mwk_cell(k)
!=========================================================================
!
!   Defines matrix of wk integrals in the B-spline basis by cell algorithm
!
!   Calls: wk_moments
!
!-------------------------------------------------------------------------
!
!   on entry
!   --------
!       k     multipole index
!
!   on exit
!   -------
!      rkb    four-dimensional array of wk integrals of power k in
!             the Spline basis (in module spline-integrals)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_integrals
    USE spline_moments
    USE spline_atomic
    IMPLICIT NONE
    INTEGER, INTENT(in) :: k
    ! .. local variables
    INTEGER(4) :: i,j, ii,jj, iv,jv, ih,jh, ihp,jhp, ip,jp
    REAL(8) :: c
    ! .. check the need of calculations
    if(itype == 'aaa') Call allocate_integrals
    if(itype == 'wk ' .and. krk == k) Return
    ! .. compute the moments in the spline basis
    Call wk_moments(k)
    ! .. assemble the moments
    rkb = 0.d0
    DO jv=1,nv
      jj = 0
      DO jh=1,ks
        j = jv + jh - 1
        DO jhp=jh,ks
          jp = jhp - jh + 1
          jj = jj + 1
          DO iv=1,nv
            ii = 0
            DO ih=1,ks
              i = iv + ih - 1
              DO ihp=1,ks
               ip = ihp - ih + ks
               ii = ii + 1
         IF( iv < jv ) THEN
                  c  = rkd3(ii,iv)*rkd2(jj,jv)
         ELSE IF( iv > jv ) THEN
                  c  = rkd1(jj,jv)*rkd4(ii,iv)
         ELSE
                  c  = rkd(ii,jj,iv)
         END IF
                  rkb(i,j,ip,jp) = rkb(i,j,ip,jp)  + c
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    rkb = rkb * fine
    itype = 'wk '
    krk = k
    END SUBROUTINE mwk_cell


!======================================================================
      REAL(8) FUNCTION nk (i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  N (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mnk_diff or mnk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp
      REAL(8), DIMENSION(ns,ks) :: a,b
      REAL(8) :: nkj
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'nk ') then
       if(meth.eq.'d') then
         Call MNK_diff(k)
       else
         Call MNK_cell(k)
       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'s')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'s')
      ! .. assembling the B-spline integrals
      nk = 0.d0
      do ip = 1,ks
        do i = 1,ns-ip+1
          nkj = 0.d0
          do jp = 1,ks
            do j = 1,ns-jp+1
              nkj = nkj+b(j,jp)*rkb(i,j,ip,jp)
            end do
          end do
          nk = nk + a(i,ip)*nkj
        end do
      end do
      END FUNCTION nk


!======================================================================
      REAL(8) FUNCTION nkc (i1,j1,i2,j2,k)
!======================================================================
!               k
!     Returns  N (i1, j1; i2, j2) - direct summations of moments
!                                   over cells
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ii, ivi,ivj, ik
      REAL(8), DIMENSION(nv) :: v1, v2
      REAL(8), DIMENSION(ks*(ks+1)/2) :: a,b
      REAL(8) :: s
      ! .. moments calculations
      Call nk_moments(k)
      ik=ks*(ks+1)/2
      nkc = 0.d0
      Do iv = 1,nv
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=i,ks
         ivj=iv+j-1
         ii = ii+1
         if(i.eq.j) then
          a(ii) = p(ivi,i1)*p(ivj,i2)
          b(ii) = p(ivi,j1)*p(ivj,j2)
         else
          a(ii) = p(ivi,i1)*p(ivj,i2) + p(ivi,i2)*p(ivj,i1)
          b(ii) = p(ivi,j1)*p(ivj,j2) + p(ivi,j2)*p(ivj,j1)
         end if
        End do
       End do
       v1(iv) = SUM(a*rkd2(1:ik,iv))
       v2(iv) = SUM(b*rkd1(1:ik,iv))
       ! .. diagonal contributions
       Do j=1,ik
        nkc = nkc + SUM(a(1:ik)*rkd(1:ik,j,iv))*b(j)
       End do
      End do
      ! .. the upper and lower regions
      s = 0.d0
      Do iv = 2,nv
       s = s + v2(iv-1)
       nkc = nkc + s*v1(iv)
      End do
      nkc = nkc * fine
      End FUNCTION nkc


!=======================================================================
      Double precision function NKy (I1,J1,I2,J2,K)
!=======================================================================
!                 k
!     Evaluates  N (i1, j1; i2, j2)  through the gaussian points
!
!
!     Calling sequence:
!
!                  NKy
!                   |
!           ----------------
!          /           |    \
!   allocate_slater   BZK   YVAL
!                      |
!                  -------------
!                 /     |       \
!              FACDZK  YVAL   dgbsl
!                |
!              dgbfa
!-----------------------------------------------------------------------
      USE spline_orbitals, p => pbs
      USE spline_grid
      USE spline_slater
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: I1,J1,I2,J2,K
      if(ky.eq.-100) Call Allocate_slater
      Call BZK (j1,j2,k,0)
      if (i1 .ne. ic1) then
        Call YVAL (0,0,0,p(1,i1),fc1)
        ic1 = i1
      end if
      if (i2 .ne. ic2) then
        Call YVAL (0,0,0,p(1,i2),fc2)
        ic2 = i2
      end if
      fc = grm*grm*grw*fc1*fc2*fyk
      nky = SUM(fc)
      nky = nky * fine
      END FUNCTION NKy


!=========================================================================
    SUBROUTINE nk_moments(k)
!=========================================================================
!
!   Defines moments for Nk-integrals in the B-spline cells
!
!   Calling sequence:          nk_moments
!                              ----------
!                               /    \\
!                           moments nk_pdiag
!                                     ||
!                                   nk_triang
!                                    /   \
!                                 gauss  vbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry    k  -  multipole index
!   --------
!
!   on exit     rkd1,rkd2,rkd - off-diagonal and diagonal moments
!   -------                     (in module spline_moments)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_moments
    USE spline_integrals
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_moments
    if(mtype == 'nk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    CALL moments(  k   , rkd1,'s','b')
    CALL moments(-(k+3), rkd2,'s','b')
    CALL nk_pdiag
    mtype = 'nk '
    kmk = k
    CONTAINS
!======================================================================
    SUBROUTINE nk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline Nk-interals
!
!   Calls:  nk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER :: iv,ik
    REAL(KIND=8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL nk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region.
    DO iv=1,ml+ks-1
      CALL nk_triang(iv)
    END DO
    ! .. the exponential region - using scaling law.
    hp=h+1.d0
    ik = ks*(ks+1)/2
    DO iv=ml+ks,ml+me-ks+2
      rkd(1:ik,1:ik,iv) = rkd(1:ik,1:ik,iv-1) / hp
    END DO
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL nk_triang(iv)
    END DO
    END SUBROUTINE nk_pdiag
!======================================================================
    SUBROUTINE nk_triang(iv)
!======================================================================
!
!   Returns the two-dimensional array of B-splin integrals
!         <B_i B_j|r2^k/r1^(k+3) E(r1-r2)|B_i' B_j'>
!   over the given triangle diagonal cell
!
!   Calls:   gauss, vbsplvd
!
!   On entry   iv  -  the index of the diagonal cell
!   --------
!
!   On exit    rkd(.,.,iv) - arrays of Nk B-spline integrals for given
!   --------                 interval iv in the reduced-dimension mode
!                            (in module spline_moments)
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: iv
    ! .. local variables
    INTEGER :: i,j, ip,jp, m,left, ii,jj
    REAL(KIND=8) :: xbase, c
    REAL(KIND=8), DIMENSION(ks) :: x,w, gx,gw
    REAL(KIND=8), DIMENSION(ks,ks) :: bspTmp
    REAL(KIND=8), DIMENSION(ks,ks,ks) :: Int
    REAL(KIND=8), DIMENSION(nv,ks,ks) :: dbiatx
    left=iv+ks-1
    xbase=t(left)
    ! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks
! .. the absolute coordinate at the new gaussian point
      gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
      DO i=1,ks
        Call vbsplvd(t,left,1,gx(i),1,dbiatx)
        bspTmp (i,:) = dbiatx(1,:,1)
      END DO
! .. and the corresponding gaussian weights
      gw(:) = (gr(iv,m)-xbase)*w(:) * gx(:)**k
!            / r(iv,m)                             k
! .. Int =  |      bsp(iv,:,j)(r) bsp(iv,:,jp)(r) r  dr
!           / r_iv
      c = grw(iv,m) * grm(iv,m)**(k+3)
      DO j=1,ks
        gx(:) = gw(:)*bspTmp(:,j)
        DO jp=j,ks
          Int(j,jp,m) = SUM(gx(:)*bspTmp(:,jp)) * c
        END DO
      END DO
    END DO    ! over m
! .. second integration
    ii = 0
    DO i=1,ks
     DO ip=i,ks
      ii = ii + 1
      gx(:) = bsp(iv,:,i)*bsp(iv,:,ip)
      jj = 0
      DO j=1,ks
       DO jp=j,ks
         jj = jj + 1
         rkd(ii,jj,iv) = SUM(gx(:)*INT(j,jp,:))
       END DO
      END DO
     END DO
    END DO
    END SUBROUTINE nk_triang
    END SUBROUTINE nk_moments


!======================================================================
      REAL(8) FUNCTION qk(i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  Q (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mqk_diff or mqk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp, imin,imax, jmin,jmax
      REAL(8), DIMENSION(ns,ks+ks-1) :: a,b
      REAL(8) :: qki
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'qk ') then
!       if(meth.eq.'d') then
!         Call Mqk_diff(k)
!       else
         Call Mqk_cell(k)
!       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'n')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'n')
      ! .. assembling the B-spline integrals
      qk = 0.d0
      do jp = 1,ks+ks-1
       jmin=max( 1, 1 + ks-jp)
       jmax=min(ns,ns + ks-jp)
       do j = jmin,jmax
        qki = 0.d0
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
           qki = qki + a(i,ip)*rkb(i,j,ip,jp)
          end do
        end do
        qk = qk + b(j,jp)*qki
       end do
      end do
      END FUNCTION qk


!======================================================================
      Real(8) FUNCTION qkc(i1,j1,i2,j2,k)
!======================================================================
!                 k
!     Return  Q (i1, j1; i2, j2) - direct summation of moments
!                                  over shell
!
!     Calls:  qk_moments          non-correct yet!!!
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ii, ivi,ivj, ik
      REAL(8), DIMENSION(nv) :: v1, v2, v3, v4
      REAL(8), DIMENSION(ks*ks) :: a,b
      REAL(8) :: s1, s2
      ! .. moments calculations
      Call qk_moments(k)
      ik=ks*ks
      qkc = 0.d0
      Do iv = 1,nv
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=1,ks
         ivj=iv+j-1
         ii = ii+1
         a(ii) = p(ivi,i1)*p(ivj,i2)
         b(ii) = p(ivi,j1)*p(ivj,j2)
        End do
       End do
       v1 (iv) = SUM(a*rkd3(:,iv))
       v2 (iv) = SUM(b*rkd2(:,iv))
       v3 (iv) = SUM(a*rkd4(:,iv))
       v4 (iv) = SUM(b*rkd1(:,iv))
       ! .. diagonal cell contribution
       Do j=1,ik
         qkc = qkc + SUM(a(1:ik)*rkd(1:ik,j,iv))*b(j)
       End do
      End do
      ! the upper and lower regions
      s1 = 0.d0
      s2 = 0.d0
      Do iv =  2,nv
       s1 = s1 + v1(iv-1)
       qkc = qkc + s1*v2(iv)
       s2 = s2 + v4(iv-1)
       qkc = qkc + s2*v3(iv)
      End do
      qkc = qkc * fine
      End FUNCTION qkc


!======================================================================
      Real(8) FUNCTION QKy (i1,j1,i2,j2,k)
!======================================================================
!
!                 k
!     Evaluates  Q (i1, j1; i2, j2) =
!
!              k                     k
!             W (i1, j1; i2, j2) -  W (j1, i1; j2, i2)
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    Integer(4), Intent(in) :: i1,j1,i2,j2,k
    Real(8), External :: WKy
    Qky =  WKy(i1,j1,i2,j2,k) - WKy(j1,i1,j2,i2,k)
    END FUNCTION QKy


!=========================================================================
    SUBROUTINE qk_moments(k)
!=========================================================================
!
!   Defines moments for Qk-integrals in the B-spline cells
!
!   Calling sequence:          qk_moments
!                              ----------
!                               /    \\
!                           moments qk_pdiag
!                                     ||
!                                   qk_triang
!                                    /   \
!                                 gauss  qbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry
!   --------
!       k     the multipole index
!
!   on exit
!   -------
!      rkd    four-dimensional array of qk integrals in diagonal cells
!      rkd1,rkd2,rkd3,rkd4 - non-diagonal shells
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_moments
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_integrals
    if(mtype == 'qk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    if(mtype == 'aaa') Call allocate_moments
    CALL moments(  k   , rkd3, 'n','d')
    CALL moments(  k-1 , rkd2, 'n','b')
    rkd3 = 2 * rkd3 + (k+2)*rkd2
    CALL moments(-(k+2), rkd2, 'n','b')
    CALL moments(-(k+3), rkd4, 'n','d')
    CALL moments(-(k+4), rkd1, 'n','b')
    rkd4 = 2 * rkd4 - (k+1)*rkd1
    CALL moments(  k+1 , rkd1, 'n','b')
    CALL qk_pdiag
    mtype = 'qk '
    kmk = k
!-----------------------------------------------------------------------
    CONTAINS
!-----------------------------------------------------------------------
!======================================================================
    SUBROUTINE qk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline Qk-interals
!
!   Calls:  qk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER(4) :: iv,ik,jk
    REAL(8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL qk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region.
    Do iv=1,ml+ks-1
      CALL qk_triang(iv)
    End do
    ! .. the log region --- using scaling law.
    hp=h+1.d0
    Do iv=ml+ks,ml+me-ks+2
      rkd(:,:,iv) = rkd(:,:,iv-1) / hp
    End do
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL qk_triang(iv)
    END DO
    END SUBROUTINE qk_pdiag
!========================================================================
    SUBROUTINE qk_triang(iv)
!========================================================================
!
!    Returns the "qk matrix element" in the diagonal cell   iv
!
!------------------------------------------------------------------------
!
!   SUBROUTINES called:
!       gauss
!       bsplvd
!
!---------------------------------------------------------------------
!
!   On entry
!   --------
!       k:     the indices of of the bsplines
!       iv:    the index of the integration region
!
!---------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: iv
! .. local variables
    INTEGER :: i,j, ip,jp, ii,jj, m, left
    REAL(KIND=8) :: xbase, c
    REAL(KIND=8), DIMENSION(ks) :: x,w,gx,gw,gv, bi
    REAL(KIND=8), DIMENSION(ks,ks) :: bspTmp,bspdTmp
    REAL(KIND=8), DIMENSION(ks,ks,ks) ::Int1,Int2
    REAL(KIND=8), DIMENSION(nv,ks,ks) :: dbiatx	
    left = iv+ks-1
    xbase = t(left)
! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks                  !  loop over old knots
! .. the absolute coordinate at the new gaussian point
      gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
      DO i=1,ks
       Call vbsplvd(t,left,1,gx(i),2,dbiatx)
       bspTmp (i,1:ks) = dbiatx(1,1:ks,1)
       bspdTmp(i,1:ks) = 2*dbiatx(1,1:ks,2) + k*bspTmp(i,1:ks)/gx(i)
      END DO
! .. and the corresponding gaussian weights
      gw(:) = (gr(iv,m)-xbase)*w(:) * gx(:)**k
!              / r(iv,m)         ___           k
! .. Int1  =  |      bsp(iv,:,i) bsp(iv,:,ip) r  dr
!             / r_iv
      c = grm(iv,m)**(k+2) * grw(iv,m)
      DO i=1,ks
       bi(:) = gw(:)*bspTmp(:,i)
       DO ip=1,ks
        Int1(i,ip,m)= SUM(bi(:)*bspdTmp(:,ip)) * c
       END DO
      END DO
!              / r(iv,m)                       k+1
! .. Int2  =  |      bsp(iv,:,j) bsp(iv,:,jp) r    dr
!             / r_iv
      gv = gw * gx
      c = grm(iv,m)**(k+3) * grw(iv,m)
      DO j=1,ks
       bi(:) = gv(:)*bspTmp(:,j)
       DO jp=1,ks
        Int2(j,jp,m)= SUM(bi(:)*bspTmp(:,jp)) * c
       END DO
      END DO
    END DO	!  over m
! ... second integration
      jj = 0
      DO j=1,ks
       DO jp=1,ks
        jj = jj + 1
        gx (:) = bsp(iv,:,j)*bsp(iv,:,jp)
        ii = 0
        DO i=1,ks
         DO ip=1,ks
          ii = ii + 1
          rkd(ii,jj,iv) = SUM( gx(:)*Int1(i,ip,:))
         END DO
        END DO
       END DO
      END DO
      Do ip=1,ks
       bspTmp(:,ip) = 2*bspd(iv,:,ip,1) - (k+3)*grm(iv,:)*bsp(iv,:,ip)
      End do
      ii = 0
      DO i=1,ks
       DO ip=1,ks
        ii = ii + 1
        gx(:) = bsp(iv,:,i)*bspTmp(:,ip)
        jj = 0
        DO j=1,ks
         DO jp=1,ks
          jj = jj + 1
          rkd(ii,jj,iv) = rkd(ii,jj,iv) + SUM( gx(:)*Int2(j,jp,:))
         END DO
        END DO
       END DO
      END DO
    END SUBROUTINE qk_triang
    END SUBROUTINE qk_moments


!======================================================================
      Double precision function  QUADR(i,j,m)
!======================================================================
!     Evaluates   <P_i | r^m | P_j>     with respect to r
!----------------------------------------------------------------------
      USE spline_param
      USE spline_galerkin
      USE spline_orbitals, p => pbs
      IMPLICIT NONE
      INTEGER, INTENT(in) :: i,j,m
      REAL(KIND=8), EXTERNAL :: BVMV
      REAL(KIND=8) :: rm(ns,ks)
      if     ( m .eq. 1 ) then
        quadr = BVMV (ns,ks, r1,'s',p(1,i),p(1,j))
      elseif ( m .eq. 0 ) then
        quadr = BVMV (ns,ks, sb,'s',p(1,i),p(1,j))
      elseif ( m .eq.-1 ) then
        quadr = BVMV (ns,ks,rm1,'s',p(1,i),p(1,j))
      elseif ( m .eq.-2 ) then
        quadr = BVMV (ns,ks,rm2,'s',p(1,i),p(1,j))
      else
        Call MRM(m,rm)
        quadr = BVMV(ns,ks,rm,'s',p(1,i),p(1,j))
      end if
      End function  QUADR


!======================================================================
      REAL(8) FUNCTION rk (i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  R (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mrk_diff or mrk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp
      REAL(8), DIMENSION(ns,ks) :: a,b
      REAL(8) :: rkj
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'rk ') then
       if(meth.eq.'d') then
         Call MRK_diff(k)
       else
         Call MRK_cell(k)
       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'s')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'s')
      ! .. assembling the B-spline integrals
      rk = 0.d0
      do ip = 1,ks
        do i = 1,ns-ip+1
          rkj = 0.d0
          do jp = 1,ks
            do j = 1,ns-jp+1
              rkj = rkj+b(j,jp)*rkb(j,i,jp,ip)
            end do
          end do
          rk = rk + a(i,ip)*rkj
        end do
      end do
      END FUNCTION rk


!======================================================================
      REAL(8) FUNCTION rkc (i1,j1,i2,j2,k)
!======================================================================
!               k
!     Returns  R (i1, j1; i2, j2) - direct summation of moments
!                                   over cells
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ii, ivi,ivj, ik
      REAL(8), DIMENSION(nv) :: v1,v2,v3,v4
      REAL(8), DIMENSION(ks*(ks+1)/2) :: a,b
      REAL(8) :: s1, s2
      !    moments calculations
      Call rk_moments(k)
      ik = ks*(ks+1)/2
      rkc= 0.d0
      Do iv = 1,nv
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=i,ks
         ivj=iv+j-1
         ii = ii+1
         if(i.eq.j) then
          a(ii) = p(ivi,i1)*p(ivj,i2)
          b(ii) = p(ivi,j1)*p(ivj,j2)
         else
          a(ii) = p(ivi,i1)*p(ivj,i2) + p(ivi,i2)*p(ivj,i1)
          b(ii) = p(ivi,j1)*p(ivj,j2) + p(ivi,j2)*p(ivj,j1)
         end if
        End do
       End do
       v1(iv) = SUM(a*rkd1(1:ik,iv))
       v2(iv) = SUM(b*rkd1(1:ik,iv))
       v3(iv) = SUM(a*rkd2(1:ik,iv))
       v4(iv) = SUM(b*rkd2(1:ik,iv))
       ! .. diagonal contributions
       Do j=1,ik
        rkc = rkc + SUM(a(1:ik)*rkd(1:ik,j,iv))*b(j)
       End do
      End do
      ! the upper and lower regions
      s1 = 0.d0
      s2 = 0.d0
      Do iv =  2,nv
        s1 = s1 + v1(iv-1)
        rkc = rkc + s1*v4(iv)
        s2 = s2 + v2(iv-1)
        rkc = rkc + s2*v3(iv)
      End do
      End FUNCTION rkc


!-----------------------------------------------------------------------
      Double precision function RKy (I1,J1,I2,J2,K)
!-----------------------------------------------------------------------
!                 k
!     Evaluates  R (i1, j1; i2, j2)  through diff. equations
!
!
!     Calling sequence:
!
!                  RKy
!           ---------------------
!          /        |            \
! Allocate_slater  YKF          YVAL
!                   |
!                 ------------------------
!                /     |     |       |    \
!             FACDYK  YVAL  VINTY  QUADR  dgbsl(LINPACK)
!               |
!             dgbfa(LINPACK)
!-----------------------------------------------------------------------
      USE spline_grid
      USE spline_orbitals, p => pbs
      USE spline_slater
      USE spline_atomic
      INTEGER, INTENT(in) :: i1,j1,i2,j2,k
      if(ky.lt.-1) Call Allocate_slater
      Call YKF (j1,j2,k)
      if (i1 .ne. ic1) then
        Call YVAL (0,0,0,p(1,i1),fc1)
        ic1 = i1
      end if
      if (i2 .ne. ic2) then
        Call YVAL (0,0,0,p(1,i2),fc2)
        ic2 = i2
      end if
      fc = grw*fc1*fc2*fyk
      rky = SUM(fc)
    END function RKy


!======================================================================
    SUBROUTINE rk_moments(k)
!======================================================================
!
!   Defines moments for Rk-integrals in the B-spline cells
!
!   Calling sequence:          rk_moments
!                              ----------
!                               /    \\
!                           moments rk_pdiag
!                                     ||
!                                   rk_triang
!                                    /   \
!                                 gauss  vbsplvb
!
!----------------------------------------------------------------------
!
!   on entry    k  -  multipole index
!   --------
!
!   on exit     rkd1,rkd2,rkd - off-diagonal and diagonal moments
!   -------                     (in module spline_moments)
!
!----------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_moments
    USE spline_atomic
    IMPLICIT NONE
    INTEGER(4), INTENT(in) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_moments
    if(mtype == 'rk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    CALL moments(  k   , rkd1,'s','b')
    CALL moments(-(k+1), rkd2,'s','b')
    CALL rk_pdiag
    ! .. add the relativistic correction
    if(rel) Call rk_rel
    mtype='rk '
    kmk=k
    CONTAINS
!======================================================================
    SUBROUTINE rk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline Rk-interals
!
!   Calls:  rk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER(4) :: iv,ik
    REAL(8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL rk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region
    DO iv=1,ml+ks-1
      CALL rk_triang(iv)
    END DO
    ! .. the exponential region - using scaling law
    hp=h+1.d0
    ik = ks*(ks+1)/2
    DO iv=ml+ks,ml+me-ks+2
      rkd(1:ik,1:ik,iv) =  rkd(1:ik,1:ik,iv-1) * hp
    END DO
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL rk_triang(iv)
    END DO
    END SUBROUTINE rk_pdiag
!======================================================================
    SUBROUTINE rk_triang(iv)
!======================================================================
!
!   Returns the two-dimensional array of B-spline integrals
!               <B_i B_j|r^k/r^(k+1)|B_i' B_j'>
!   over the given triangle diagonal cell
!
!   Calls:   gauss, vbsplvd
!
!   On entry   iv  -  index of the diagonal cell
!   --------
!
!   On exit    rkd(.,.,iv) - arrays of Rk B-spline integrals for given
!   --------                 interval iv in the reduced-dimension mode
!                            (in module spline_moments)
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER(4), INTENT(IN) :: iv
    ! .. local variables
    INTEGER(4) :: i,j, ip,jp, ii,jj, m, left,  ik
    REAL(8) :: xbase, c
    REAL(8), DIMENSION(ks) :: x,w, bi, gx,gw
    REAL(8), DIMENSION(ks,ks) :: bspTmp
    REAL(8), DIMENSION(ks,ks,ks) :: INT
    REAL(8), DIMENSION(nv,ks,ks) :: dbiatx
    REAL(8), DIMENSION(ks*(ks+1)/2,ks*(ks+1)/2) :: a
    left=iv+ks-1
    xbase=t(left)
! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks
! .. the absolute coordinate at the new gaussian point
      gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
      DO i=1,ks
       CALL vbsplvd(t,left,1,gx(i),1,dbiatx)
       bspTmp(i,1:ks)= dbiatx(1,1:ks,1)
      END DO
! .. and the corresponding gaussian weights
      gw(:) = (gr(iv,m)-xbase)*w(:)
      IF(k>1) THEN
        gx(:) = gw(:)*gx(:)**k
      ELSE IF(k==1) THEN
        gx(:) = gw(:)*gx(:)
      ELSE IF(k==0) THEN
        gx(:) = gw(:)
      END IF
!            / r(iv,m)                             k
! .. INT =  |      bsp(iv,:,j)(r) bsp(iv,:,jp)(r) r  dr
!           / r_iv
      DO j=1,ks
       gw(:) = gx(:)*bspTmp(:,j)
       DO jp=j,ks
        INT(j,jp,m)= SUM(gw(:)*bspTmp(:,jp))
       END DO
      END DO
    END DO	 !  over m
! .. second integration
    IF(k/=0) THEN
      gx(:) = grw(iv,:)*grm(iv,:)**(k+1)
    ELSE
      gx(:) = grw(iv,:)*grm(iv,:)
    END IF
    ii = 0
    DO i=1,ks
     DO ip=i,ks
      ii = ii+1
      bi(:) = bsp(iv,:,i)*bsp(iv,:,ip)*gx(:)
      jj = 0
      DO j=1,ks
       DO jp=j,ks
        jj = jj + 1
        a(ii,jj) =  SUM(bi(:)*INT(j,jp,:))
       END DO
      END DO
     END DO
    END DO
    ik = ks*(ks+1)/2
    rkd(1:ik,1:ik,iv) = a + TRANSPOSE(a)
    END SUBROUTINE rk_triang
!======================================================================
    SUBROUTINE rk_rel
!======================================================================
!
!   relativistic corrections to the Rk integrals
!
!   (they have another scaling multiplier, then RK !)
!
!----------------------------------------------------------------------
    Implicit none
    REAl(8) :: C
    REAl(8), DIMENSION(ks) :: a,b
    Integer(4) :: iv, i,j, ip,jp, ii,jj
     C = fine*(k+k+1)
     Do iv = 1,nv
     a(:) = grm(iv,:)*grm(iv,:)*grw(iv,:) * C
     ii = 0
     DO i=1,ks
      DO ip=i,ks
       ii = ii+1
       b(:) = bsp(iv,:,i)*bsp(iv,:,ip)*a(:)
       jj = 0
       DO j=1,ks
        DO jp=j,ks
         jj = jj + 1
         rkd(ii,jj,iv) = rkd(ii,jj,iv) +  &
                         SUM(b(:)*bsp(iv,:,j)*bsp(iv,:,jp))
        END DO
       END DO
      END DO
     END DO
     END DO
    End SUBROUTINE rk_rel
    END SUBROUTINE rk_moments


!======================================================================
      Subroutine R_bwfn (nu)
!======================================================================
!
!     read radial orbitals in B-spline representation from file 'nu'
!
!----------------------------------------------------------------------
      USE spline_atomic
      USE spline_param
      USE spline_orbitals
      IMPLICIT NONE
      Integer(4), Intent(in) :: nu
      Character(4) :: el
      Real(8) :: zw,hw,hmw,rmw
      Integer(4) :: ksw,nsw,mw,n,l,k,i
      Integer(4), External :: Iadd_bsorb
      rewind(nu)
    1 read(nu,end=2) el,zw,hw,hmw,rmw,ksw,nsw,mw
      if(zw.ne.z) Stop ' R_bwfn:  z <> zw'
      if(abs(hw-h).gt.1.d-12) Stop ' R_bwfn:  h <> hw'
      if(abs(hmw-hmax).gt.1.d-12) Stop ' R_bwfn:  hmw <> hmax'
      if(abs(rmw-rmax).gt.1.d-12) Stop ' R_bwfn:  rmw <> rmax'
      if(ksw.ne.ks) Stop ' R_bwfn:  ksw <> ks'
      if(nsw.ne.ns) Stop ' R_bwfn:  nsw <> ns'
      Call EL4_nlk(el,n,l,k)
      i = Iadd_bsorb(n,l,k)
      read(nu) pbs(1:mw,i)
      mbs(i) = mw
      if(mw.lt.ns) pbs(mw+1:ns,i) = 0.d0
      go to 1
    2 Continue
      End Subroutine R_bwfn


!======================================================================
      SUBROUTINE SPLIN3 (N, X, Y, B, C, D)
!======================================================================
!
!     THE COEFFICIENTS B(I), C(I), AND D(I), I=1,2,...,N  ARE COMPUTED
!     FOR A CUBIC INTERPOLATING SPLINE
!
!     S(X) = Y(I) + B(I)*(X-X(I)) + C(I)*(X-X(I))**2 + D(I)*(X-X(I))**3
!
!     FOR  X(I) .LE. X .LE. X(I+1)
!
!     INPUT:
!
!     N = THE NUMBER OF DATA POINTS OR KNOTS (N=>2)
!     X = THE ABSCISSAS OF THE KNOTS IN STRICTLY INCREASING ORDER
!     Y = THE ORDINATES OF THE KNOTS
!
!     OUTPUT:
!
!     B, C, D  = ARRAYS OF SPLINE COEFFICIENTS AS DEFINED ABOVE.
!
!     USING  P  TO DENOTE DIFFERENTIATION:
!     Y(I) = S(X(I))
!     B(I) = SP(X(I))
!     C(I) = SPP(X(I))/2
!     D(I) = SPPP(X(I))/6  (DERIVATIVE FROM THE RIGHT)
!
!     THE ACCOMPANYING FUNCTION  'SEVAL'  CAN BE USED
!     TO EVALUATE THE SPLINE.
!----------------------------------------------------------------------
      IMPLICIT NONE
      Integer(4), Intent(in) :: N
      Real(8), Intent(in), Dimension(n) :: X,Y
      Real(8), Intent(out), Dimension(n) :: B,C,D
      Integer(4) :: I,J,M
      Real(8) :: T
      IF ( N .LT. 2 ) RETURN
      IF ( N .LT. 3 ) THEN ! liniar interpolation for n = 2 :
       B(1) = (Y(2)-Y(1))/(X(2)-X(1)); C(1)=0.d0; D(1)=0.d0
       B(2) = B(1);  C(2)=0.d0; D(2)=0.d0
       RETURN
      END IF
      M = N-1
! ... SET UP TRIDIAGONAL SYSTEM
! ... B = DIAGONAL, D = OFFDIAGONAL, C = RIGHT HAND SIDE.
      D(1) = X(2) - X(1)
      C(2) = (Y(2) - Y(1))/D(1)
      Do I = 2, M
         D(I) = X(I+1) - X(I)
         B(I) = 2*(D(I-1) + D(I))
         C(I+1) = (Y(I+1) - Y(I))/D(I)
         C(I) = C(I+1) - C(I)
      End do
! ... END CONDITIONS. THIRD DERIVATIVES AT  X(1)  AND  X(N)
! ... OBTAINED FROM DIVIDED DIFFERENCES
      B(1) = -D(1)
      B(N) = -D(N-1)
      C(1) = 0.
      C(N) = 0.
      IF ( N .GT. 3 ) THEN
       C(1) = C(3)/(X(4)-X(2)) - C(2)/(X(3)-X(1))
       C(N) = C(N-1)/(X(N)-X(N-2)) - C(N-2)/(X(N-1)-X(N-3))
       C(1) = C(1)*D(1)**2/(X(4)-X(1))
       C(N) = -C(N)*D(N-1)**2/(X(N)-X(N-3))
      END IF
!     FORWARD ELIMINATION
      Do I = 2, N
         T = D(I-1)/B(I-1)
         B(I) = B(I) - T*D(I-1)
         C(I) = C(I) - T*C(I-1)
      End do
! ... BACK SUBSTITUTION
      C(N) = C(N)/B(N)
      Do J = 1, M
       I=N-J; C(I) = (C(I) - D(I)*C(I+1))/B(I)
      End do
! ... C(I) IS NOW THE SIGMA(I) OF THE TEXT
! ... COMPUTE POLYNOMIAL COEFFICIENTS
      B(N) = (Y(N) - Y(M))/D(M) + D(M)*(C(M) + 2.*C(N))
      Do I = 1, M
         B(I) = (Y(I+1) - Y(I))/D(I) - D(I)*(C(I+1) + 2.*C(I))
         D(I) = (C(I+1) - C(I))/D(I)
         C(I) = 3.*C(I)
      End do
      C(N) = 3.*C(N);  D(N) = D(N-1)
      END SUBROUTINE SPLIN3
!=======================================================================
      Real(8) function SEVAL(N,U,X,Y,B,C,D)
!=======================================================================
!
!     Evaluates the value of cubic spline for abscisa U
!
!-----------------------------------------------------------------------
      IMPLICIT NONE
      Integer(4), Intent(in) :: N
      Real(8), Intent(in) :: U
      Real(8), Intent(in), Dimension(N) :: X,Y,B,C,D
      Integer(4) :: mflag, I
      Real(8) :: DX
      Call INTERV (X,N,U,I,mflag)
      DX=U-X(I); SEVAL=Y(I)+DX*(B(I)+DX*(C(I)+DX*D(I)))
      End function SEVAL


!======================================================================
    REAL(8) FUNCTION SUM_AmB(ns,ks,a,b,sym)
!======================================================================
!
!   Returns  SUM ( a * b)  for banded and full matrixes
!
!   sym = 's' - symmetrical banded matrix
!   sym = 'n' - non-symmetrical banded matrix
!   sym = 'x' - full matrix
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER(4), INTENT(in) :: ns,ks
    CHARACTER(1), INTENT(in) :: sym
    REAL(8), INTENT(in), DIMENSION(ns,*) :: a,b
    INTEGER(4) :: i,j, imin,imax
    REAL(8) :: x
    x = 0.d0
    if(sym.eq.'x') then
     Do i = 1,ns
      Do j = 1,ns
       x = x + a(i,j)*b(i,j)
      End do
     End do
    elseif(sym.eq.'s') then
     Do j = 1,ks
      Do i = 1,ns-j+1
       x = x + a(i,j)*b(i,j)
      End do
     End do
    elseif(sym.eq.'n') then
     Do j = 1,ks+ks-1
      imin=max( 1, 1+ks-j)
      imax=min(ns,ns+ks-j)
      Do i = imin,imax
       x = x + a(i,j)*b(i,j)
      End do
     End do
    else
     Stop ' SUM_AmB:  unknown symmetry '
    end if
    SUM_AmB = x
    END FUNCTION SUM_AmB


!======================================================================
      REAL(8) FUNCTION tk(i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  T (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mtk_diff or mtk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp, imin,imax, jmin,jmax
      REAL(8), DIMENSION(ns,ks+ks-1) :: a,b
      REAL(8) :: tki
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'tk ') then
       if(meth.eq.'d') then
         Call MTK_diff(k)
       else
         Call MTK_cell(k)
       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'n')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'n')
      ! .. assembling the B-spline integrals
      tk = 0.d0
      do jp = 1,ks+ks-1
       jmin=max( 1, 1 + ks-jp)
       jmax=min(ns,ns + ks-jp)
       do j = jmin,jmax
        tki = 0.d0
        do ip = 1,ks+ks-1
          imin=max( 1, 1 + ks-ip)
          imax=min(ns,ns + ks-ip)
          do i = imin,imax
           tki = tki + a(i,ip)*rkb(i,j,ip,jp)
          end do
        end do
        tk = tk + b(j,jp)*tki
       end do
      end do
      END FUNCTION tk


!======================================================================
      REAL(8) FUNCTION tkc (i1,j1,i2,j2,k)
!======================================================================
!               k
!     Returns  T (i1, j1; i2, j2) - direct summations of moments
!                                   over cells
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ii, ivi,ivj, ik
      REAL(8), DIMENSION(nv) :: v1, v2, v3, v4
      REAL(8), DIMENSION(ks*ks) :: a,b
      REAL(8) :: s1, s2
      !    moments calculations
      Call tk_moments(k)
      ik=ks*ks
      tkc = 0.d0
      Do iv = 1,nv
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=1,ks
         ivj=iv+j-1
         ii = ii+1
         a(ii) = p(ivi,i1)*p(ivj,i2)
         b(ii) = p(ivi,j1)*p(ivj,j2)
        End do
       End do
       v1 (iv) = SUM(a*rkd1(:,iv))
       v2 (iv) = SUM(b*rkd1(:,iv))
       v3 (iv) = SUM(a*rkd2(:,iv))
       v4 (iv) = SUM(b*rkd2(:,iv))
       ! .. diagonal contributions
       Do j=1,ik
         tkc = tkc + SUM(a(1:ik)*rkd(1:ik,j,iv))*b(j)
       End do
      End do
      ! the upper and lower regions
      s1 = 0.d0
      s2 = 0.d0
      Do iv =  2,nv
       s1 = s1 + v1(iv-1)
       tkc = tkc + s1*v4(iv)
       s2 = s2 + v2(iv-1)
       tkc = tkc + s2*v3(iv)
      End do
      tkc = tkc * fine / (k + k + 1)
      End FUNCTION tkc


!=======================================================================
      Double precision function TKy (I1,J1,I2,J2,K)
!=======================================================================
!                 k
!     Evaluates  T (i1, j1; i2, j2)  through diff. equations
!
!
!     Calling sequence:
!
!                  TKy
!           -------------------
!          /        ||        |
!  Allocate_slater  YTK      YVAL
!                    |
!                 ------------------------
!                /     |     |       |    \
!             FACDYK  YVAL  VINTY  QUADR  dgbsl(LINPACK)
!               |
!             dgbfa(LINPACK)
!-----------------------------------------------------------------------
      USE spline_orbitals, p => pbs, L => lbs
      USE spline_grid
      USE spline_slater
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: I1,J1,I2,J2,K
      if(ky.eq.-100) Call Allocate_slater
      Call Ytk(j1,j2,k)
      if (i1 .ne. ic1) then
        Call YVAL (0,0,0,p(1,i1),fc1)
        ic1 = i1
      end if
      if (i2 .ne. ic2) then
        Call YVAL (0,0,0,p(1,i2),fc2)
        ic2 = i2
      end if
      Call YVAL (1,0,0,p(1,i2),fc)
      fc = fc - grm*fc2
      fc = fc*fc1*fyk*grw
      tky = SUM(fc)
      tky = tky * fine / (k+k+1)
      CONTAINS
!=====================================================================
      Subroutine ytk(j1,j2,k)
!=====================================================================
!
!     Computes the spline solution of the differential equation
!
!           (d^2-k(k+1)/r^2)yk(r)= -(2k+1)(1/r) P_1(r)P'_2(r)
!
!     Calls:  yval,  vinty, dgbtrs (lapack) or dgbfa (linpack)
!                           dgbtrf             dgbsl
!     on exit
!     -------
!     yk    spline expansion of the solution
!     fyk   values at the gaussian points * (1/r)
!---------------------------------------------------------------------
       USE spline_param;  USE spline_galerkin
       IMPLICIT NONE
       INTEGER, INTENT(in) :: j1,j2,k
       INTEGER :: jj,jp,info
       REAL(8) :: c
       REAL(8), EXTERNAL :: QUADR
! ... create the numerical values of the orbitals on the grid
      if (iy1 .ne. j1) then
        Call YVAL (0,0,0,p(1,j1),fy1)
        iy1 = j1
      end if
      if (iy2 .ne. j2) then
        Call YVAL (0,0,0,p(1,j2),fy2)
        iy2 = j2
      end if
! ... set up the array of yk(i) = INTEGRAL 'r^m*fc1(r)*fc2'(r)*B_i(r)'
      Call YVAL (1,0,0,p(1,j2),fc)
      fc = fc - grm*fy2
      fc = fc*fy1*grw*grm
      Call Vinty(fc,yk)
      c = - (2*k+1)
      yk = c*yk
! ... boundary conditions:
      yk(1)   = 0.d0
      yk(ns)  = 0.d0   !  Assume that p(ns)=0.d0 for input w.f.'s
      if( k.eq.0 .and. l(j1).eq.l(j2) ) then  ! INT( p_j1(r)*p'_j2(r) dr)
        c =  0.d0
        do jp = 2,ks
          do jj = jp+1,ns-jp+1
            c =  c  +    db1(jj,ks-jp+1) *   &
               ( p(jj,j2)*p(jj-jp+1,j1) - p(jj,j1)*p(jj-jp+1,j2) )
          end do
        end do
        yk(ns) = c - QUADR(j1,j2,-1)
      end if
! ... set up and factor the differential operator ...
      if(k.ne.ky) Call FACDYK (ktx,k,ipvtd,dyk)
      ky = k
! ... solve the matrix equation
!     CALL dgbsl(dyk,ktx,ns,ks-1,ks-1,ipvtd,yk,0) ! LINPACK
      Call DGBTRS ('N',ns,ks-1,ks-1,1,dyk,3*ks-2,ipvtd,yk,ns,info)
      if( info .ne. 0 ) Stop 'TKy: dgbtrs (LAPACK) failed'
! ... evaluates the function (1/r)yk(r) at all the gaussian points
      Call YVAL (0,0,-1,yk,fyk)
      END SUBROUTINE Ytk
      END FUNCTION TKy


!=========================================================================
    SUBROUTINE tk_moments(k)
!=========================================================================
!
!   Defines moments for Tk-integrals in the B-spline cells
!
!   Calling sequence:          tk_moments
!                              ----------
!                               /    \\
!                           moments tk_pdiag
!                                     ||
!                                   tk_triang
!                                    /   \
!                                 gauss  vbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry    k  -  multipole index
!   --------
!
!   on exit     rkd1,rkd2,rkd - off-diagonal and diagonal moments
!   -------                     (in module spline_moments)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_moments
    IMPLICIT NONE
    INTEGER(4), INTENT(in) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_moments
    if(mtype == 'tk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    CALL moments(  k   , rkd1,'n','d')
    CALL moments(-(k+1), rkd2,'n','d')
    CALL tk_pdiag
    mtype = 'tk '
    kmk = k
    CONTAINS
!======================================================================
    SUBROUTINE tk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline Tk-interals
!
!   Calls:  tk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER :: iv, jk
    REAL(KIND=8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL tk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region
    Do iv=1,ml+ks-1
      CALL tk_triang(iv)
    End do
    ! .. the exponential region - using scaling law
    hp=h+1.d0
    jk = ks*ks
    Do iv=ml+ks,ml+me-ks+2
      rkd(1:jk,1:jk,iv) = rkd(1:jk,1:jk,iv-1) / hp
    End do
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL tk_triang(iv)
    END DO
    END SUBROUTINE tk_pdiag
!========================================================================
    SUBROUTINE tk_triang(iv)
!========================================================================
!
!   Returns the two-dimensional array of B-splin Tk-integrals
!                                  _    _
!         <B_i B_j| r2^k/r1^(k+1) |B_i' B_j'>
!
!   over the given triangle diagonal cell
!
!   Calls:   gauss, vbsplvd
!
!   On entry   iv  -  the index of the diagonal cell
!   --------
!
!   On exit    rkd(.,.,iv) - arrays of B-spline Tk-integrals for given
!   --------                 interval iv in the reduced-dimension mode
!                            (in module spline_moments)
!----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER, INTENT(in) :: iv
! .. local variables
      INTEGER :: i,j, ii,jj, ip,jp, m, left, jk
      REAL(KIND=8) :: xbase
      REAL(KIND=8), DIMENSION(ks) :: x,w, gx,gw
      REAL(KIND=8), DIMENSION(ks,ks) :: bspTmp, bspdTmp
      REAL(KIND=8), DIMENSION(ks,ks,ks) :: INT
      REAL(KIND=8), DIMENSION(nv,ks,ks) :: dbiatx
      REAL(KIND=8), DIMENSION(ks*ks,ks*ks) :: a
      left=iv+ks-1
      xbase=t(left)
! .. setup the gaussian points
      CALL gauss(ks,x,w)
! .. first integration
      DO m=1,ks
! .. the absolute coordinate at the new gaussian point
       gx(1:ks) = (gr(iv,m)-xbase)*x(1:ks) + xbase
! .. the bspline values at the new gaussian points
       DO i=1,ks
        Call vbsplvd(t,left,1,gx(i),2,dbiatx)
        bspTmp (i,1:ks) = dbiatx(1,1:ks,1)
        bspdTmp(i,1:ks) = dbiatx(1,1:ks,2)-bspTmp(i,1:ks)/gx(i)
      END DO
! .. and the corresponding gaussian weights
       gw(1:ks) = (gr(iv,m)-xbase)*w(1:ks)
       gx(1:ks) = gx(1:ks)**k * gw(1:ks)
!            / r(iv,m)         ___           k
! .. INT =  |      bsp(iv,:,j) bsp(iv,:,jp) r  dr
!           / r_iv
       DO j=1,ks
        gw(1:ks) = gx(1:ks) * bspTmp(1:ks,j)
        DO jp=1,ks
          INT(j,jp,m)= SUM(gw(1:ks) * bspdTmp(1:ks,jp))
        END DO
       END DO
      END DO    ! over m
! .. second integration
      gx(1:ks) = grw(iv,1:ks)*grm(iv,1:ks)**(k+1)
      Do ip=1,ks
       bspTmp(1:ks,ip) = bsq(iv,1:ks,ip)*gx(1:ks)
      End do
      ii = 0
      DO i=1,ks
       DO ip=1,ks
        ii = ii + 1
        gx(1:ks) =  bsp(iv,1:ks,i)*bspTmp(1:ks,ip)
        jj = 0
        DO j=1,ks
         DO jp=1,ks
          jj = jj + 1
          a(ii,jj) = SUM(gx(1:ks)*INT(j,jp,1:ks))
         END DO
        END DO
       END DO
      END DO
      jk = ks*ks
      rkd(1:jk,1:jk,iv) = a + Transpose(a)
      END SUBROUTINE tk_triang
      END SUBROUTINE tk_moments


!=======================================================================
   SUBROUTINE vbsplvd(t, kg, ni, x, nderiv, dbiatx)
!=======================================================================
!
!  This routine calculates the values of the B-splines and their deriva-
!  tives, of order up to nderiv, that do not vanish at x(i), i=1,..ni
!  There are ks such B-splines at each point.
!
!  This routine is a vector version of bsplvd written by C. de Boor,
!  ``A Practical Guide to Splines".
!
!  subroutine contained: vbsplvb
!
!  calling sequence:
!       vbsplvd
!          ||
!       vbsplvb
!
!-----------------------------------------------------------------------
!  on entry
!  --------
!  t     the knot array, of length nt >=nv+2ks-1.  It is assumed
!        that t(i) < t(i+1) for each interval containing an x(i)
!        Division by zero will result otherwise (in vbsplvb).
!
!  kg    gives the beginning interval from which the B-splines are
!        evaluated at the Gaussian points.
!
!  ni    the number of intervals in which B-splines are to be evaluated
!        at all Gaussian points, its uplimit is nt.
!
!  x     the point array at which these values are sought,
!        one per interval, of length ni.
!
!  nderiv   an integer indicating that values of B-splines and their
!        derivatives up to but not including the  nderiv-th  are asked
!        for.
!
!  working area
!  ------------
!  w31   a three dimensional array, w31(i,j,m) (j=1,..,ks m=1,..,ks) con-
!        tains B-coeff.s of the derivatives of a certain order of the
!        ks B-splines of interest at point x(i)
!
!  w1,w2      one dimensional arrays
!
!  on return
!  ---------
!  dbiatx     a three dimensional array. its entry (i,j,m) contains
!        value of  (m-1)st  derivative of  (l-ks+j)-th B-spline of
!        order ks at point x(i) for knot sequence t, i=1..ni,
!        j=m..ks; m=1..nderiv;and l=kg..kg+ni-1
!
!  method
!  ------
!  values at x(i) of all the relevant B-splines of order ks,ks-1,...,
!  ks+1-nderiv  are generated via vbsplvb and stored temporarily
!  in dbiatx. then, the B-coeffs of the required derivatives of the
!  B-splines of interest are generated by differencing, each from the
!  preceding one of lower order, and combined with the values of B-
!  splines of corresponding order in dbiatx to produce the desired
!  values.
!----------------------------------------------------------------------
    USE spline_param
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: kg, ni, nderiv
    REAL(KIND=8), DIMENSION(ns+ks), INTENT(IN) :: t
    REAL(KIND=8), DIMENSION(nv,ks,ks), INTENT(INOUT):: dbiatx
    REAL(KIND=8), DIMENSION(ni), INTENT(IN):: x
    ! local variables
    REAL(KIND=8):: fkpimm
    REAL(KIND=8), DIMENSION(ni):: w1,w2
    REAL(KIND=8), DIMENSION(ni,ks,ks):: w31
    REAL(KIND=8), DIMENSION(ni,ks) :: deltar, deltal
    INTEGER:: i, j, n, m, mhigh, kp1, jhigh, ideriv
    INTEGER:: ldummy, kpimm, jlow, jpimid, il
    mhigh = MAX(MIN(nderiv,ks),1)   !mhigh is usually equal to nderiv.
    kp1 = ks+1
    jhigh = kp1-mhigh
    CALL vbsplvb(kg,ni,x,jhigh,1,dbiatx)
    IF(mhigh == 1) RETURN
    ! ..the first row of dbiatx always contains the B-spline values
    ! ..for the current order. these are stored in row ks+1-current
    ! ..order before vbsplvb is called to put values for the next
    ! ..higher order on top of it. Vbsplvb only uses the first two dimensions
    ideriv = mhigh
    DO m = 2, mhigh
      jpimid = 1
      DO j = ideriv,ks
       dbiatx(1:ni,j,ideriv) = dbiatx(1:ni,jpimid,1)
       jpimid = jpimid+1
      END DO
      ideriv = ideriv-1
      jhigh = kp1-ideriv	
      CALL vbsplvb(kg,ni,x,jhigh,2,dbiatx)
    END DO
    ! at this point,  b(.,n-ks+i, ks+1-j)(x) is in dbiatx(.,i,j) for
    ! n=kg..kg+ni-1,i=j..ks,j=1..mhigh('='nderiv).in particular,the
    ! first row of  dbiatx  is already in final form. to obtain cor-
    ! responding derivatives of B-splines in subsequent rows, gene-
    ! rate their B-repr. by differencing, then evaluate at x(.).
    jlow = 1
    DO i = 1,ks
      w31(1:ni,jlow:ks,i) = 0.d0	
      jlow = i
      w31(1:ni,i,i) = 1.d0
    END DO
    ! at this point, w31(.,.,j) contains the B-coeffs for the j-th of the
    ! ks B-splines of interest here.
    DO m = 2,mhigh
      kpimm = kp1-m
      fkpimm = kpimm
      i = ks
      il = 0
      ! for j=1,...,ks, construct B-coeffs of  (m-1)st  derivative of
      ! B-splines from those for preceding derivative by differencing
      ! and store again in  w31(.,.,j). the fact that w31(i,j) = 0  for
      ! i < j is used.
      DO ldummy = 1, kpimm
       DO n = kg-il,ni+kg-il-1
        w1(n-kg+il+1) = fkpimm/(t(n+kpimm)-t(n))
       END DO
        ! the assumption that t(n) < t(n+1) makes denominator
        ! in w1(1..ni) nonzero.
        DO j = 1,i
         w31(1:ni,i,j) = (w31(1:ni,i,j)-w31(1:ni,i-1,j))*w1(1:ni)
        END DO
        il = il+1
        i = i-1
      END DO
      ! for i=1,...,ks, combine B-coeffs a(.,.,i) with B-spline values
      ! stored in dbiatx(.,.,m) to get value of (m-1)st  derivative of
      ! i-th B-spline (of interest here) at x(.), and store in
      ! dbiatx(.,i,m). storage of this value over the value of a B-spline
      ! of order m there is safe since the remaining B-spline derivat-
      ! ive of the same order do not use this value due to the fact
      ! that  a(.,j,i) = 0  for j .lt. i .
      DO i = 1,ks
        w2(1:ni) = 0.d0
        jlow = MAX(i,m)
        DO j = jlow,ks
          w2(1:ni) = w2(1:ni) + w31(1:ni,j,i)*dbiatx(1:ni,j,m)
        END DO
        dbiatx(1:ni,i,m) = w2(1:ni)
      END DO
    END DO
    CONTAINS
    !===================================================================
      SUBROUTINE vbsplvb(kg, ni, x, jhigh, index, biatx)
    !=====================================================================
    !  This routine calculates the values of all possibly nonzero B-splines
    !  at x(i) (i=1,..ni) of order
    !               jout=max(jhigh,(j+1)*(index-1))
    !  with knot sequence  t .
    !
    !  This routine is a vector version of bsplvb written by C. de Boor,
    !  "A Practical Guide to Splines", Chapter X, page 135
    !
    !  on entry
    !  --------
    !  t    -  knot sequence, of length nt=ns+ks, assumed to be nonde-
    !          creasing, that is t(i) <= t(i+1)
    !
    !  jhigh-  choose jhigh=1 to get the B-spline values directly
    !            by calling vbsplvb.
    !
    !  kg   -  gives the beginning interval from which the B-splines
    !           are to be evaluated at Gaussin points.
    !
    !  ni   -  the number of intervals in which B-splines are
    !            evaluated at all Gaussian points, its uplimit is nv.
    !
    !  x    -  the points at which the B-splines are to be evaluated,
    !            its length is ni,
    !
    !  index-  integers which determine the order  jout = max(jhigh,
    !            (j+1)*(index-1))  of the B-splines whose values at x(i)
    !            are to be returned.  index is used to avoid recalcula-
    !            tions when several columns of the triangular array of
    !            B-spline values are needed (e.g., in vbsplvd ).
    !            More precisely,
    !                     if index = 1 ,
    !            the calculation starts from scratch and the entire
    !            triangular array of B-spline values of orders
    !            1,2,...,jhigh is generated, order by order ,
    !            i.e., column by column .
    !                     if  index = 2 ,
    !            only the B-spline values of order  j+1, j+2, ..., jout
    !            are generated, the assumption being that  biatx,j,
    !            deltal,deltar are, on  entry, as they were on exit at the
    !            previous call. In particular, if  jhigh = 0, then
    !            jout = j+1, i.e., just the next column of B-spline
    !            values is generated.
    !
    !  working area
    !  ------------
    !  deltal, deltar: two dimensional arrays
    !  term, saved:    one dimensional arrays.
    !
    !  on return
    !  ---------
    !  biatx.....two dimensional array, with biatx(j-k+1,i)(j=k..ni)
    !        containing the value at x(j-k+1) of the polynomial of order
    !        jout which agrees with the B-spline b(j-jout+1,jout,t) on
    !        the interval (t(j),t(j+1)).
    !
    !  method
    !  ------
    !  The recurrence relation
    !
    !                       x - t(i)              t(i+j+1) - x
    !     b(i,j+1)(x)  =  -----------b(i,j)(x) + ---------------b(i+1,j)(x)
    !                     t(i+j)-t(i)            t(i+j+1)-t(i+1)
    !
    !  is used (repeatedly) to generate the (j+1)-vector  b(l-j,j+1)(x),
    !  ...,b(l,j+1)(x)  from the j-vector  b(l-j+1,j)(x),...,
    !  b(l,j)(x), storing the new values in  biatx  over the old. the
    !  facts that
    !            b(i,1) = 1  if  t(i) <= x < t(i+1)
    !  and that
    !            b(i,j)(x) = 0  unless  t(i) <= x < t(i+j)
    !  are used. the particular organization of the calculations follows al-
    !  gorithm  (8)  in chapter x of the text.
    !-----------------------------------------------------------------------
        USE spline_param
        IMPLICIT NONE
        REAL(KIND=8), DIMENSION(nv,ks), INTENT(INOUT):: biatx
        REAL(KIND=8), DIMENSION(nv), INTENT(IN):: x
        INTEGER, INTENT(IN):: kg, ni, jhigh, index
        ! .. Local variables
        INTEGER:: i, jp1, m
        INTEGER, SAVE:: j=1
        REAL(KIND=8), DIMENSION(ni) :: term, saved
        IF(index == 1) THEN
          j=1
          biatx(1:ni,1)=1.d0
          IF (j >= jhigh)  RETURN
        END IF
        DO
          jp1=j+1
          saved(1:ni)=0.d0
          DO i=1,ni
            deltar(i,j)=t(i+kg-1+j)-x(i)
            deltal(i,j)=x(i)-t(i+kg-j)
          END DO 	
          DO m=1,j
            DO i=1,ni
              term(i)=biatx(i,m)/(deltar(i,m)+deltal(i,jp1-m))
              biatx(i,m)=saved(i)+deltar(i,m)*term(i)
              saved(i)=deltal(i,jp1-m)*term(i)
            END DO
          END DO
          biatx(1:ni,jp1)=saved(1:ni)
          j=jp1
          IF (j >= jhigh) EXIT
        END DO
      END SUBROUTINE vbsplvb
  END SUBROUTINE vbsplvd


!====================================================================
    SUBROUTINE vinty(ygr,yv)
!====================================================================
!
!   Computes the vector elements   <B_i, y(r)>
!
!--------------------------------------------------------------------
!
!   on entry
!   --------
!       ygr   array of values of a specific function  y(r) at the
!             gaussian points of each interval, weighted by the
!             gaussian weight
!
!   on exit
!   -------
!       yv    vector of integrals of <B_i, y(r)>, where i=1,..,ns
!
!--------------------------------------------------------------------
    USE spline_param; USE spline_grid
    IMPLICIT NONE
    REAL(8), DIMENSION(nv,ks), INTENT(IN) :: ygr
    REAL(8), DIMENSION(ns), INTENT(INOUT) :: yv
    INTEGER :: ith, i, m
    yv = 0.d0
    do ith = 1,ks
      do i = 1,nv
        do m = 1,ks
          yv(i+ith-1) = yv(i+ith-1) + ygr(i,m)*bsp(i,m,ith)
        end do
      end do
    end do
  END SUBROUTINE vinty


!======================================================================
      REAL(8) FUNCTION vk(i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  V (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mvk_diff or mvk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp, imin,imax
      REAL(8), DIMENSION(ns,ks+ks-1) :: a
      REAL(8), DIMENSION(ns,ks) :: b
      REAL(8) :: vki
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'vk ') then
       if(meth.eq.'d') then
         Call MVK_diff(k)
       else
         Call MVK_cell(k)
       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'n')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'s')
      ! .. assembling the B-spline integrals
      vk = 0.d0
      do jp = 1,ks
       do j = 1,ns-jp+1
        vki = 0.d0
        do ip = 1,ks+ks-1
         imin=max( 1, 1 + ks-ip)
         imax=min(ns,ns + ks-ip)
         do i = imin,imax
          vki = vki + a(i,ip)*rkb(i,j,ip,jp)
         end do
        end do
        vk = vk + b(j,jp)*vki
       end do
      end do
      END FUNCTION vk


!======================================================================
      REAL(8) FUNCTION vkc(i1,j1,i2,j2,k)
!======================================================================
!               k
!     Returns  V (i1, j1; i2, j2) - direct summations of moments
!                                   over cells
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals, p => pbs
      USE spline_moments
      USE spline_atomic
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: i1,j1,i2,j2,k
      ! .. local variables
      INTEGER(4) :: i,j, iv, ivi, ivj, ii, ik,jk
      REAL(8), DIMENSION(nv) :: v1, v2, v3, v4
      REAL(8), DIMENSION(ks*ks) ::  a, b
      REAL(8) :: s1, s2
      ! .. check the need of calculations
      Call vk_moments(k)
      ik = ks*(ks+1)/2
      jk = ks*ks
      vkc = 0.d0
      Do iv = 1,nv
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=1,ks
         ivj=iv+j-1
         ii = ii+1
         a(ii) = p(ivi,i1)*p(ivj,i2)
        End do
       End do
       ii=0
       Do i=1,ks
        ivi=iv+i-1
        Do j=i,ks
         ivj=iv+j-1
         ii = ii+1
         if(i.eq.j) then
          b(ii) = p(ivi,j1)*p(ivj,j2)
         else
          b(ii) = p(ivi,j1)*p(ivj,j2) + p(ivi,j2)*p(ivj,j1)
         end if
        End do
       End do
       v1(iv) = SUM(rkd3(1:jk,iv)*a)
       v2(iv) = SUM(rkd2(1:ik,iv)*b)
       v3(iv) = SUM(rkd4(1:jk,iv)*a)
       v4(iv) = SUM(rkd1(1:ik,iv)*b)
       ! the diagonal cell contribution
       Do j = 1,ik
        vkc = vkc + SUM(a(1:jk)*rkd(1:jk,j,iv))*b(j)
       End do
      End do
      ! the upper and lower regions
      s1 = 0.d0
      s2 = 0.d0
      Do iv =  2,nv
       s1 = s1 + v1(iv-1)
       vkc = vkc + s1*v2(iv)
       s2 = s2 + v4(iv-1)
       vkc = vkc + s2*v3(iv)
      End do
      vkc = vkc * fine
      End FUNCTION vkc


!=======================================================================
      Double precision function VKy (I1,J1,I2,J2,K)
!=======================================================================
!                 k
!     Evaluates  V (i1, j1; i2, j2)  through the diff. equations
!
!
!     Calling sequence:
!
!                   VKy
!           --------------------
!          /       ||          |
! Allocate_slater  YVK        YVAL
!                   |
!                -----------------------
!               /     |     |      |    \
!             BZK  YVAL  VINTY   FACDZK  dgbsl
!              |                    |
!            -----------          dgbfa
!            |      |   \
!          FACDZK  YVAL  dgbsl
!            |
!          dgbfa
!
!-----------------------------------------------------------------------
      USE spline_orbitals, p => pbs
      USE spline_grid
      USE spline_slater
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: I1,J1,I2,J2,K
      if(ky.eq.-100) Call Allocate_slater
      Call YVK (j1,j2,k)
      if (i1 .ne. ic1) then
        Call YVAL (0,0,0,p(1,i1),fc1)
        ic1 = i1
      end if
      if (i2 .ne. ic2) then
        Call YVAL (0,0,0,p(1,i2),fc2)
        ic2 = i2
      end if
      Call YVAL (1,0,0,p(1,i2),fc)
      fc = fc - grm*fc2
      fc = fc*fc1*fyk*grm*grm*grw
      vky = SUM(fc)
      vky = vky * fine
      CONTAINS
!=====================================================================
      Subroutine yvk(j1,j2,k)
!=====================================================================
!
!     Computes the spline solution of the differential equation
!
!           (d - (k+kk)/r) yk(r)= -(2k+kk)(1/r) zk(r)
!
!     with yk(ns) = zk(ns)
!
!     Calls:  bzk, yval, vinty, dgbtrs (lapack) or dgbfa (linpack)
!                               dgbtrf             dgbsl
!     on exit
!     -------
!     yk    spline expansion of the solution
!     fyk   values at the gaussian points * (1/r)
!---------------------------------------------------------------------
       USE spline_param; USE spline_galerkin
       IMPLICIT NONE
       INTEGER, INTENT(in) :: j1,j2,k
       REAL(8) :: fk, yns
       Integer(4) :: info
!  ... calculation of Zk function ...
       Call BZK (j1,j2,k,1)
       yns = yk(ns)
!  ... set up the array of yk(i) = INTEGRAL '1/r zk(r) B_i(r)'
       fc = grw * fyk
       Call Vinty(fc,yk)
       fk = - (k+k+3)
       yk = fk * yk
!  ... set up and factor the differential operator ...
       if(kz.ne.-(k+3)) CALL FACDZK(ktx,-(k+3),dzk,ipvtz)
       kz = -(k+3)
!  ... boundary conditions:    yk(ns) = zk(ns)
        yk(ns) = yns
!  ... solve the matrix equation
!      CALL dgbsl(dzk,ktx,ns,ks-1,ks-1,ipvtz,yk,0) ! LINPACK
       Call DGBTRS ('N',ns,ks-1,ks-1,1,dzk,3*ks-2,ipvtz,yk,ns,info)
       if( info .ne. 0 ) Stop 'VKy: dgbtrs (LAPACK) failed'
! ... evaluates the function (1/r)yk(r) at all the gaussian points
      Call YVAL (0,0,-1,yk,fyk)
      END SUBROUTINE YVK
      END FUNCTION VKy


!=========================================================================
    SUBROUTINE vk_moments(k)
!=========================================================================
!
!   Defines moments for Vk-integrals in the B-spline cells
!
!   Calling sequence:          vk_moments
!                              ----------
!                               /    \\
!                           moments vk_pdiag
!                                     ||
!                                   vk_triang
!                                    /   \
!                                 gauss  vbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry    k  -  multipole index
!   --------
!
!   on exit     rkd1,rkd2,rkd - off-diagonal and diagonal moments
!   -------                     (in module spline_moments)
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_moments
    IMPLICIT NONE
    INTEGER, INTENT(in) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_moments
    if(mtype == 'vk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    CALL moments(  k+1 , rkd1,'s','b')
    CALL moments(-(k+2), rkd2,'s','b')
    CALL moments(  k   , rkd3,'n','d')
    CALL moments(-(k+3), rkd4,'n','d')
    CALL vk_pdiag
    mtype = 'vk '
    kmk = k
    CONTAINS
!======================================================================
    SUBROUTINE vk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline Vk-interals
!
!   Calls:  vk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER(4) :: iv,ik,jk
    REAL(8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL vk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region.
    Do iv=1,ml+ks-1
      CALL vk_triang(iv)
    End do
    ! .. the log region --- using scaling law.
    jk = ks*ks
    ik = ks*(ks+1)/2
    hp=h+1.d0
    Do iv=ml+ks,ml+me-ks+2
      rkd(1:jk,1:ik,iv) = rkd(1:jk,1:ik,iv-1) / hp
    End do
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL vk_triang(iv)
    END DO
    END SUBROUTINE vk_pdiag
!========================================================================
    SUBROUTINE vk_triang(iv)
!========================================================================
!
!   Returns the two-dimensional array of B-splin Vk-integrals
!                                  _
!         <B_i B_j| (r<)^k/(r>)^(k+1) |B_i' B_j' r2 >
!
!   over the given triangle diagonal cell
!
!   Calls:   gauss, vbsplvd
!
!   On entry   iv  -  the index of the diagonal cell
!   --------
!
!   On exit    rkd(.,.,iv) - arrays of B-spline Vk-integrals for given
!   --------                 interval iv in the reduced-dimension mode
!                            (in module spline_moments)
!----------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: iv
! .. local variables
    INTEGER(4) :: i,j, ip,jp, m, left, ii,jj
    REAL(8) :: xbase, c
    REAL(8), DIMENSION(ks) :: x,w,gx,gw, bi
    REAL(8), DIMENSION(ks,ks) :: bspTmp,bspdTmp
    REAL(8), DIMENSION(ks,ks,ks) ::Int1,Int2
    REAL(8), DIMENSION(nv,ks,ks) :: dbiatx	
    left = iv+ks-1
    xbase = t(left)
! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks                  !  loop over old knots
! .. the absolute coordinate at the new gaussian point
     gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
     DO i=1,ks
      Call vbsplvd(t,left,1,gx(i),2,dbiatx)
      bspTmp (i,1:ks) = dbiatx(1,1:ks,1)
      bspdTmp(i,1:ks) = dbiatx(1,1:ks,2) - bspTmp(i,1:ks)/gx(i)
     END DO
! .. and the corresponding gaussian weights
     gw(:) = (gr(iv,m)-xbase)*w(:) * gx(:)**k
!              / r(iv,m)         ___           k
! .. Int1  =  |      bsp(iv,:,i) bsp(iv,:,ip) r  dr
!             / r_iv
     c = grm(iv,m)**(k+2) * grw(iv,m)
     DO i=1,ks
      bi(:) = gw(:)*bspTmp(:,i)
      DO ip=1,ks
       Int1(i,ip,m)= SUM(bi(:)*bspdTmp(:,ip)) * c
      END DO
     END DO
!              / r(iv,m)                       k+1
! .. Int2  =  |      bsp(iv,:,j) bsp(iv,:,jp) r    dr
!             / r_iv
      gw = gw * gx
      c = grm(iv,m)**(k+3) * grw(iv,m)
      DO j=1,ks
       bi(:) = gw(:)*bspTmp(:,j)
       DO jp=1,ks
        Int2(j,jp,m)= SUM(bi(:)*bspTmp(:,jp)) * c
       END DO
      END DO
     END DO	!  over m
! .. second integration
     jj = 0
     DO j=1,ks
      DO jp=j,ks
       jj = jj + 1
       gx(:) = bsp(iv,:,j)*bsp(iv,:,jp)
       ii = 0
       DO i=1,ks
        DO ip=1,ks
         ii = ii + 1
         rkd(ii,jj,iv) = SUM(gx(:)*Int1(i,ip,:))
        END DO
       END DO
      END DO
     END DO
     ii = 0
     DO i=1,ks
      DO ip=1,ks
       ii = ii + 1
       gx(:) = bsp(iv,:,i)*bsq(iv,:,ip)
       jj = 0
       DO j=1,ks
        DO jp=j,ks
         jj = jj + 1
         rkd(ii,jj,iv) = rkd(ii,jj,iv) + SUM(gx(:)*Int2(j,jp,:))
       END DO
      END DO
     END DO
    END DO
    END SUBROUTINE vk_triang
    END SUBROUTINE vk_moments


!======================================================================
      REAL(8) FUNCTION wk(i1,j1,i2,j2,k,meth)
!======================================================================
!               k
!     Returns  W (i1, j1; i2, j2) base on the assembling the B-spline
!     integrals, which are supposed to be placed in the module
!     spline-integrals. If not, they are calculated by programs
!     mwk_diff or mwk_cell, depending of the parameter 'meth':
!     meth = 'd' - differential equation method
!          = 'c' - cell integration method
!----------------------------------------------------------------------
      USE spline_param
      USE spline_orbitals
      USE spline_integrals
      IMPLICIT NONE
      INTEGER(4), INTENT(in) :: i1,j1,i2,j2,k
      CHARACTER(1), INTENT(in), OPTIONAL :: meth
      ! .. local variables
      INTEGER(4) :: i,ip, j,jp, imin,imax
      REAL(8), DIMENSION(ns,ks+ks-1) :: a
      REAL(8), DIMENSION(ns,ks) :: b
      REAL(8) :: wki
      ! .. check the B-spline integrals in module spline-integrals
      if(k.ne.krk.or.itype.ne.'wk ') then
!       if(meth.eq.'d') then
!         Call Mwk_diff(k)
!       else
         Call Mwk_cell(k)
!       end if
      end if
      ! .. form cross-products
      Call density (ns,ks,a,pbs(1,i1),pbs(1,i2),'n')
      Call density (ns,ks,b,pbs(1,j1),pbs(1,j2),'s')
      ! .. assembling the B-spline integrals
      wk = 0.d0
      do jp = 1,ks
       do j = 1,ns-jp+1
        wki = 0.d0
        do ip = 1,ks+ks-1
         imin=max( 1, 1 + ks-ip)
         imax=min(ns,ns + ks-ip)
         do i = imin,imax
          wki = wki + a(i,ip)*rkb(i,j,ip,jp)
         end do
        end do
        wk = wk + b(j,jp)*wki
       end do
      end do
      END FUNCTION wk


!======================================================================
      Real(8) FUNCTION WKy (i1,j1,i2,j2,k)
!======================================================================
!
!                 k                          k
!     Evaluates  W (i1, j1; i2, j2) =   2   V   (i1, j1; i2, j2)
!                                            k+1
!                                    -(k+1) N   (i1, j1; i2, j2)
!                                            k-1
!                                    +(k+2) N   (j1, i1, j2, i2)
!----------------------------------------------------------------------
    IMPLICIT NONE
    Integer(4), Intent(in) :: i1,j1,i2,j2,k
    Real(8), External :: VKy, NKy
    Wky = 2 * VKy(i1,j1,i2,j2,k) - (k+1) * NKy(i1,j1,i2,j2,k+1)  &
                                 + (k+2) * NKy(j1,i1,j2,i2,k-1)
    END FUNCTION WKy


!=========================================================================
    SUBROUTINE wk_moments(k)
!=========================================================================
!
!   Defines moments for Wk-integrals in the B-spline cells
!
!   Calling sequence:          wk_moments
!                              ----------
!                               /    \\
!                           moments wk_pdiag
!                                     ||
!                                   wk_triang
!                                    /   \
!                                 gauss  qbsplvb
!
!-------------------------------------------------------------------------
!
!   on entry
!   --------
!       k     the multipole index
!
!   on exit
!   -------
!      rkd    four-dimensional array of wk integrals in diagonal cells
!      rkd1,rkd2,rkd3,rkd4 - non-diagonal shells
!
!-------------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    USE spline_galerkin
    USE spline_moments
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k
    ! .. check the need of calculations
    if(mtype == 'aaa') Call allocate_integrals
    if(mtype == 'wk ' .and. kmk == k) Return
    ! .. compute the moments in the spline basis
    if(mtype == 'aaa') Call allocate_moments
    CALL moments(  k   , rkd3, 'n','d')
    CALL moments(  k-1 , rkd2, 'n','b')
    rkd3 = 2 * rkd3 + (k+2)*rkd2
    CALL moments(-(k+2), rkd2, 's','b')
    CALL moments(-(k+3), rkd4, 'n','d')
    CALL moments(-(k+4), rkd1, 'n','b')
    rkd4 = 2 * rkd4 - (k+1)*rkd1
    CALL moments(  k+1 , rkd1, 's','b')
    CALL wk_pdiag
    mtype = 'wk '
    kmk = k
!-----------------------------------------------------------------------
    CONTAINS
!-----------------------------------------------------------------------
!======================================================================
    SUBROUTINE wk_pdiag
!======================================================================
!
!   Controls the scaling propeties for diagonal B-spline wk-interals
!
!   Calls:  wk_triang
!
!----------------------------------------------------------------------
    IMPLICIT NONE
    ! .. local variables
    INTEGER(4) :: iv,ik,jk
    REAL(8) :: hp
    ! .. non-exponential grid
    if(me.eq.0) then
     DO iv=1,nv
      CALL wk_triang(iv)
     END DO
     Return
    end if
    ! .. the first equal step region.
    Do iv=1,ml+ks-1
      CALL wk_triang(iv)
    End do
    ! .. the log region --- using scaling law.
    jk = ks*ks
    ik = ks*(ks+1)/2
    hp=h+1.d0
    Do iv=ml+ks,ml+me-ks+2
      rkd(1:jk,1:ik,iv) = rkd(1:jk,1:ik,iv-1) / hp
    End do
    ! .. the last equal step region
    DO iv=ml+me-ks+3,nv
      CALL wk_triang(iv)
    END DO
    END SUBROUTINE wk_pdiag
!========================================================================
    SUBROUTINE wk_triang(iv)
!========================================================================
!
!    Returns the "wk matrix element" in the diagonal cell   iv
!
!------------------------------------------------------------------------
!
!   SUBROUTINES called:
!       gauss
!       bsplvd
!
!---------------------------------------------------------------------
!
!   On entry
!   --------
!       k:     the indices of of the bsplines
!       iv:    the index of the integration region
!
!---------------------------------------------------------------------
    IMPLICIT NONE
    INTEGER, INTENT(in) :: iv
! .. local variables
    INTEGER :: i,j, ip,jp, ii,jj, m, left
    REAL(KIND=8) :: xbase, c
    REAL(KIND=8), DIMENSION(ks) :: x,w,gx,gw,gv, bi
    REAL(KIND=8), DIMENSION(ks,ks) :: bspTmp,bspdTmp
    REAL(KIND=8), DIMENSION(ks,ks,ks) ::Int1,Int2
    REAL(KIND=8), DIMENSION(nv,ks,ks) :: dbiatx	
    left = iv+ks-1
    xbase = t(left)
! .. setup the gaussian points
    CALL gauss(ks,x,w)
    DO m=1,ks                  !  loop over old knots
! .. the absolute coordinate at the new gaussian point
      gx(:) = (gr(iv,m)-xbase)*x(:) + xbase
! .. the bspline values at the new gaussian points
      DO i=1,ks
       Call vbsplvd(t,left,1,gx(i),2,dbiatx)
       bspTmp (i,1:ks) = dbiatx(1,1:ks,1)
       bspdTmp(i,1:ks) = 2*dbiatx(1,1:ks,2) + k*bspTmp(i,1:ks)/gx(i)
      END DO
! .. and the corresponding gaussian weights
      gw(:) = (gr(iv,m)-xbase)*w(:) * gx(:)**k
!              / r(iv,m)         ___           k
! .. Int1  =  |      bsp(iv,:,i) bsp(iv,:,ip) r  dr
!             / r_iv
      c = grm(iv,m)**(k+2) * grw(iv,m)
      DO i=1,ks
       bi(:) = gw(:)*bspTmp(:,i)
       DO ip=1,ks
        Int1(i,ip,m)= SUM(bi(:)*bspdTmp(:,ip)) * c
       END DO
      END DO
!              / r(iv,m)                       k+1
! .. Int2  =  |      bsp(iv,:,j) bsp(iv,:,jp) r    dr
!             / r_iv
      gv = gw * gx
      c = grm(iv,m)**(k+3) * grw(iv,m)
      DO j=1,ks
       bi(:) = gv(:)*bspTmp(:,j)
       DO jp=j,ks
        Int2(j,jp,m)= SUM(bi(:)*bspTmp(:,jp)) * c
       END DO
      END DO
    END DO	!  over m
! ... second integration
      jj = 0
      DO j=1,ks
       DO jp=j,ks
        jj = jj + 1
        gx (:) = bsp(iv,:,j)*bsp(iv,:,jp)
        ii = 0
        DO i=1,ks
         DO ip=1,ks
          ii = ii + 1
          rkd(ii,jj,iv) = SUM( gx(:)*Int1(i,ip,:))
         END DO
        END DO
       END DO
      END DO
      Do ip=1,ks
       bspTmp(:,ip) = 2*bspd(iv,:,ip,1) - (k+3)*grm(iv,:)*bsp(iv,:,ip)
      End do
      ii = 0
      DO i=1,ks
       DO ip=1,ks
        ii = ii + 1
        gx(:) = bsp(iv,:,i)*bspTmp(:,ip)
        jj = 0
        DO j=1,ks
         DO jp=j,ks
          jj = jj + 1
          rkd(ii,jj,iv) = rkd(ii,jj,iv) + SUM( gx(:)*Int2(j,jp,:))
         END DO
        END DO
       END DO
      END DO
    END SUBROUTINE wk_triang
    END SUBROUTINE wk_moments


!=====================================================================
      Subroutine ykf (j1,j2,k)
!=====================================================================
!     Computes the spline solution of the differential equation
!
!           (d^2-k(k+1)/r^2)yk(r)= -(2k+1)(1/r) P_1(r)P_2(r)
!
!     on exit   (in module spline_slater)
!     -------
!     yk    spline expansion of the solution
!     fyk   values at the gaussian points * (1/r)
!
!   Calling sequence:
!
!              YKF
!       ------------------------
!      /     |     |       |    \
!   FACDYK  YVAL  VINTY  QUADR  dgbtrs(LAPACK) or dgbsl(LINPACK)
!     |
!   dgbfa(LINPACK)
!---------------------------------------------------------------------
      USE spline_param
      USE spline_grid
      USE spline_slater
      USE spline_orbitals, p => pbs
      USE spline_atomic
      IMPLICIT NONE
      INTEGER, INTENT(in) :: j1,j2,k
! ..  local variables
      REAL(8) :: c
      REAL(8), EXTERNAL :: QUADR
      Integer(4) :: info
!  ... create the numerical values of the orbitals on the grid
       if (iy1 .ne. j1) then
         Call YVAL (0,0,0,p(1,j1),fy1)
         iy1 = j1
       end if
       if (iy2 .ne. j2) then
         Call YVAL (0,0,0,p(1,j2),fy2)
         iy2 = j2
       end if
!  ... set up the array of yk(i) = INTEGRAL [(1/r)fc1(r)fc2(r)*B_i(r)]
       fc = grw*grm*fy1*fy2
       Call Vinty(fc,yk)
       c = - (2*k+1)
       yk = c*yk
!  ... boundary conditions:
       yk(1)  = 0.d0
       yk(ns) = 0.d0
       if( k.eq.0 ) yk(ns) = QUADR(j1,j2,0)
!  ... set up and factor the differential operator ...
       if(k.ne.ky) Call FACDYK (ktx,k,ipvtd,dyk)
       ky = k
!  ... solve the matrix equation
!      CALL dgbsl(dyk,ktx,ns,ks-1,ks-1,ipvtd,yk,0)
       Call DGBTRS ('N',ns,ks-1,ks-1,1,dyk,ktx,ipvtd,yk,ns,info)
       if( info .ne. 0 ) Stop 'YKF: dgbtrs failed (LAPACK)'
!  ... evaluates function (1/r)yk(r) at the gaussian points
       Call YVAL (0,0,-1,yk,fyk)
!  ... add a relativistic correction if irel > 0
        if (rel) then
          c = (k+k+1)*fine
          fyk = fyk + c*grm*grm*fy1*fy2
        end if
     END SUBROUTINE ykf


!=======================================================================
      Subroutine YVAL (id,iw,mm,yv,ygr)
!=======================================================================
!
!     This routine computes the values of  r^mm f(r), f'(r), f''(r)
!     at the gaussian points of each interval, where f(r) is defined
!     by the spline expansion vector yv.
!
!     on entry
!     --------
!     id      indivates derivatives of f(r)	(=0,1,2)
!     iw      if iw > 0, results are weighted by gaussian coef.s
!     mm      integer defining the power of r
!     yv      the spline expansion vector for the funciton f(r)
!
!     on exit
!     -------
!     ygr     array of values of r^mm f(r) at the gaussian points
!             of each interval
!-----------------------------------------------------------------------
    USE spline_param
    USE spline_grid
    IMPLICIT NONE
    INTEGER, INTENT(in) :: id,iw,mm
    REAL(KIND=8), DIMENSION(ns), INTENT(in) :: yv
    REAL(KIND=8), DIMENSION(nv,ks), INTENT(out) :: ygr
    ! .. local variables
    INTEGER :: m, i, ith
    REAL(KIND=8), DIMENSION(nv,ks) :: gw
    if(mm.eq. 0) then
       gw = 1.d0
    elseif(mm.eq. 1) then
       gw = gr
    elseif(mm.eq.-1) then
       gw = grm
    elseif(mm.gt. 1) then
       gw = gr**mm
    elseif(mm.lt.-1) then
       gw = grm**(-mm)
    end if
    if(iw.ne.0) gw = gw * grw
    ygr = 0.d0
    if(id.eq.0) then
    do m = 1,ks
      do i = 1,nv
        do ith = 1,ks
         ygr(i,m) = ygr(i,m) + yv(i+ith-1)*bsp(i,m,ith)*gw(i,m)
       end do
      end do
     end do
    elseif(id.eq.1.or.id.eq.2) then
     do m = 1,ks
      do i = 1,nv
       do ith = 1,ks
        ygr(i,m) = ygr(i,m) + yv(i+ith-1)*bspd(i,m,ith,id)*gw(i,m)
       end do
      end do
     end do
    end if
    End Subroutine YVAL


!======================================================================
      Real(8) FUNCTION ZETA_y (I1,I2)
!======================================================================
!
!   COMPUTES THE NUCLEAR SPIN-ORBIT PARAMETER AND THE
!   CORRECTIONS FOR THE COMMON CLOSED SHELLS
!
!   Calls:  QUADR, NKy, VKy  - integrals
!           ZCB - 3j-symbol (to determine angular part of the intershell
!                            interaction)
!----------------------------------------------------------------------
      USE spline_orbitals, p => pbs, L => lbs
      USE spline_atomic, nclosd => kclosd
      IMPLICIT NONE
      INTEGER, INTENT(in) :: i1,i2
      REAL(KIND=8), EXTERNAL :: QUADR, NKy, VKy, ZCB
      INTEGER :: i, LA,LB, k,kmin,kmax, k1,k2, m1,m2, iv,iw, ink,in2
      REAL(KIND=8) :: ZETA, ZZ, QA, CB
      REAL(KIND=8) :: DNK,ENK,SNK,DVK,EVK,SVK,SN2,DN2,EN2
      if(L(i1).ne.L(i2)) Stop ' ZETA: L(i1) <> L(i2)'
      if(L(i1).eq.0) Stop ' ZETA: L = 0 '
      ZETA = fine*Z*QUADR(I1,I2,-3)
      LB = L(I1)
      DO I = 1,NCLOSD
        LA = L(I)
        QA = 4*LA+2
        ZETA = ZETA - QA*NKy(I1, I, I2, I, 0)
        kmin=iabs(LB-LA)
        kmax=iabs(LB+LA)
        Do k=kmin,kmax,2
          cb = 3*QA*ZCB(LA,k,LB)/(8*LB*(LB+1))
          k1 = k + 1
          DNK = NKy(I1, I, I, I2, K)
          ENK = NKy(I, I1, I2, I, K)
          SNK = (DNK + ENK)/(k+1)
          SVK = 0.d0
          SN2 = 0.d0
          if(k.gt.0) then
           DN2 = NKy(I1, I, I, I2, K-2)
           EN2 = NKy(I, I1, I2, I, K-2)
           SN2 = (DN2 + EN2)/k
           DVK = 2*VKy(I1,I,I,I2,K-1) - k*DNK + (k+1)*EN2
           EVK = 2*VKy(I,I1,I2,I,K-1) - k*ENK + (k+1)*DN2
           SVK = DVK - EVK
          end if
          IW=LB*(LB+1)-LA*(LA+1)
          IV=IW+k*k1
          M1=(LA+LB+1)
          m1=m1*m1
          m2=m2*m2
          M2=(LA-LB)
          K1=(K+1)*(K+1)
          K2=K*K
          INK=(M1-K1)*(K1-M2)
          IN2=(M1-K2)*(K2-M2)
          ZZ = IV*(SVK + IW*(SNK-SN2)) + INK*SNK - IN2*SN2
          ZETA = ZETA + ZZ*cb
        End do
      End do
      ZETA_y = ZETA
      END FUNCTION ZETA_y


